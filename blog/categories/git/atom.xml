<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Git | 思考的轨迹]]></title>
  <link href="http://shanewfx.github.com/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://shanewfx.github.com/"/>
  <updated>2013-08-14T14:28:36+08:00</updated>
  <id>http://shanewfx.github.com/</id>
  <author>
    <name><![CDATA[Shane]]></name>
    <email><![CDATA[shanewfx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[迁移VSS版本库到Git]]></title>
    <link href="http://shanewfx.github.com/blog/2012/05/09/migrate-from-vss-to-git/"/>
    <updated>2012-05-09T16:10:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/05/09/migrate-from-vss-to-git</id>
    <content type="html"><![CDATA[<p>公司最近有意将版本控制工具从VSS和CVS切换到Git上，由于之前的项目一直是使用VSS和CVS进行版本管理，这次迁移免不了要涉及VSS和CVS版本库向Git进行转换的工作。</p>

<p>带着这个目的，我先尝试着找到VSS到Git迁移的可行方案，因为我之前的项目一直也是用VSS进行版本管理，相对于从没有使用过的CVS而言，应该更容易上手一些。至于CVS如何迁移到Git会在后面进行研究。</p>

<!--more-->


<p>之前在学习使用GitStack搭建Git服务器时，在其官方网站上看到一篇讲如何<a href="http://gitstack.com/migrate-from-svn-to-git/">迁移SVN版本库到Git</a>的文章，文中有提到git svn命令，可见Git内部已经有了对SVN版本库进行操作的支持，继而顺着这个思路，试着去找找有没有支持对VSS和CVS的操作，结果发现Git没有对VSS的操作支持，对于CVS倒是有git cvsimport，但在Git Bash中却不认识该命令，运行<code>git help vcsimport</code>也没有相关的文档，而使用<code>git help vcs-migration</code>倒是有文档，其中也提到了git cvsimport，难道是我是在Windows上使用的Git（安装的是msysGit 1.7.10），而在Windows上还不支持该命令吗？不知道在Linux上的情况是怎么样的？</p>

<p>这个问题暂时先搁置，先研究一下如何将原有的VSS版本库迁移到Git上。</p>

<p>既然Git没有对VSS的支持，那么VSS转Git应该是需要第三方的工具来帮助实现这个转换工作（该工具要读取并分析VSS仓库的数据，然后按照Git版本库的内部结构来存放之前VSS版本库中的数据），按照这个思路，在Google上搜索了一下，果然发现有一个这样的工具，那就是<a href="http://code.google.com/p/vss2git/">vss2git</a>，而且是个开源的项目，很对我的胃口。</p>

<p>下载下来并试用了一下，结果成功将之前的一个用VSS管理的项目转换为Git仓库，并且<strong>之前VSS的历史信息也被保留下来</strong>，基本是满足了要求。</p>

<h3>VSS版本库到Git的迁移</h3>

<p>打开VSS2Git，其界面就是一个对话框，在其中作一些必要的设置，主要是设置VSS版本库所在的路径、要转换VSS版本库中哪一个项目（也可以是整个VSS版本库中全部的项目）、转换结果的存放位置、转换Log存放的位置、转换过程中创建Git提交对象时所需的email的domain等，设置好这些之后，点击Go按键即可开始VSS到Git仓库的转换。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/7163442740/" title="Flickr 上 shanewfx 的 VSS2Git"><img src="http://farm8.staticflickr.com/7088/7163442740_845fe43252.jpg" width="500" height="340" alt="VSS2Git"></a></p>

<p>转换所需的时间长短取决于VSS仓库的大小，如果VSS仓库中项目众多，且开发的时间都比较久的话，那么完成整个仓库的转换应该需要的时间会比较长，但如果只是转换其中一个项目到Git，那么时候会比较短。</p>

<p>转换后，通过<code>git log</code>可以看到之前VSS仓库中的历史信息，而且这些历史信息在Git仓库中仍然是按照提交时间的先后来排列的。</p>

<p>在转换过程中，打开存放Git仓库的目录，你会发现工作目录随着时间会在变化，这是因为VSS2Git在转换时会先分析并收集VSS仓库中的各种信息，然后再从VSS仓库中记录的最早的时间点开始Replay（演绎）整个VSS仓库数据形成的过程。</p>

<p>在演绎过程中，应该是先从VSS中取出最初的版本（Git仓库最初为一个空仓库），并将其版本中的文件作为Git工作目录的文件，然后按照Git先对工作目录进行文件快照再提交到Git仓库的做法，按照时间顺序逐个版本进行提交（提交时会取出VSS中对应版本的历史信息），最终将VSS版本库转换为Git仓库。</p>

<p>上述的演绎过程是我自己初步推断的大概过程，实际是否这么实现，请参考VSS2Git的源代码（用C#实现的）。
另外，VSS仓库内部的数据到底是如何组织的我也没有研究过。</p>

<p><strong>要注意的几点：</strong></p>

<ul>
<li><p>如果是要将整个VSS仓库中的所有项目都迁移到Git中，那么在VSS2Git界面的Project一项中填上<code>$</code></p></li>
<li><p>如果只是要将VSS仓库中的某一个项目迁移到Git上，则在Project一项中应填上<code>$/Project1</code> (其中Project1为假设的项目名)，甚至可以仅转换子项目，这样<code>$/Project1/32Bit</code></p></li>
<li><p>VSS2Git一次要么完成VSS仓库的整体转换，要么只能转换VSS仓库中其中一个项目，这样要实现多个项目的转换就要多次执行VSS2Git</p></li>
<li><p>VSS2Git的每一次转换会产生一个Git仓库，如果是VSS仓库一次整体转换，则生成的Git仓库中将包含VSS仓库中所有的项目，这样带来的问题是，由于Git仓库中包含了所有的项目，这样以后不同项目的开发人员无法从Git仓库中只checkout出自己负责的那个项目文件，而是要checkout出所有项目的文件，这样对于公司的代码安全是非常不利的，那么，这样就不应该一次将VSS仓库整体转换，而是应该以项目为单位进行逐个转换，这样，对于不同的项目，对其Git仓库就可以为不同的开发人员设置不同的操作权限</p></li>
<li><p>VSS2Git在生成Git提交信息所需的email时，只是根据从VSS中提取出的User名加上在界面Email domain中填写的内容组合而成，实际生成的email地址未必是有效的（不一定能用来发送email）</p></li>
</ul>


<p>更多的注意事项可至<a href="http://code.google.com/p/vss2git/">VSS2Git的主页</a>查看。</p>

<h3>导入现有的Git仓库到GitStack服务器上</h3>

<p>通过VSS2Git，我们可以将VSS仓库中的项目逐一转换为该项目的Git仓库，这时我们可以将其放置到Git服务器上了，以便后续的开发和维护。</p>

<p>这里，我们假设使用GitStack搭建了Git服务器（如何搭建见<a href="http://shanewfx.github.com/blog/2012/05/03/git-server-based-on-gitstack/">上篇</a>），现在的问题就相当于如何将一个现有的Git仓库导入到GitStack搭建的服务器上。因为正常的流程是在GitStack上先创建裸仓库，然后再向其中提交，如果这样做的话，我们之前的VSS中的历史信息恐怕就要丢失了，而这是我们不希望的结果。</p>

<p>不过幸运的是，GitStack支持导入一个现有的Git仓库到其中，其步骤也很简单，就是先将现有的Git仓库拷贝至C:\GitStack\repositories目录下面，然后登陆到GitStack上，在Repositories列表中会发现我们的Git仓库已经在其中，但Action栏则出现了一个绿色的安装，而非添加用户、查看仓库的那些按钮，这时我们只有点击这个绿色按钮就完成了该Git仓库的导入，之后我们会发现绿色的按钮被正常的添加用户、查看仓库的那些按钮替换掉，这时我们就可以为该Git仓库添加用户并设置访问权限了。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/7163501304/" title="Flickr 上 shanewfx 的 gitstack"><img src="http://farm6.staticflickr.com/5160/7163501304_4d08fab433.jpg" width="500" height="210" alt="gitstack"></a></p>

<p>具体的过程，在GitStack的文档中有详细的阐述，请见<a href="http://gitstack.com/import-an-existing-repository/">Import an existing repository</a>，这里不再赘述。</p>

<p>至此，如何将VSS仓库迁移到Git，并将生成的Git仓库导入到GitStack搭建的服务器上的大概过程就结束了。</p>

<p>（全文完）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于GitStack搭建Git中心服务器]]></title>
    <link href="http://shanewfx.github.com/blog/2012/05/03/git-server-based-on-gitstack/"/>
    <updated>2012-05-03T20:10:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/05/03/git-server-based-on-gitstack</id>
    <content type="html"><![CDATA[<p>通过前一段时间对Git的学习，基本掌握了Git常用命令的使用方法，并进行了总结，有兴趣的可以看看<a href="http://shanewfx.github.com/blog/2012/04/28/git-command-note/">Git常用命令的使用情景</a>和<a href="http://shanewfx.github.com/blog/2012/04/21/learn-git-command/">Git学习笔记</a>。</p>

<p>在<a href="http://shanewfx.github.com/blog/2012/04/28/git-command-note/">Git常用命令的使用情景</a>中提到过多人协作的项目往往是需要一个中心服务器来同步多人之间的工作成果，另外，最终的工作成果通常也是中心服务器上的代码为准（为了项目管理的需要），因此，备份时往往需要对中心服务器上的仓库进行刻盘。</p>

<p>中心服务器上创建的项目仓库一般为裸仓库（没有工作目录），且需要为项目开发人员设置访问和操作中心服务器上仓库的权限（访问、读、写）。</p>

<p>本文将介绍如何使用开源软件<a href="http://gitstack.com/">GitStack</a>在Windows上搭建Git中心服务器。</p>

<!--more-->


<p>为了学习如何在Windows上搭建Git服务器，用Google搜索了一下，发现多数的方案是采用CopSSH + msysgit + PuTTY的方式来实现，这种方案使用<a href="http://zh.wikipedia.org/wiki/SSH">SSH</a>协议（采用公钥和私钥进行身份验证，用<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">PuTTY</a>可以产生公钥和私钥，关于公钥和私钥可参考<a href="http://www.360doc.com/content/12/0502/18/1016783_208170505.shtml">这篇</a>入门介绍）与Git服务器通信，在安全性上应该来说是比较高的，但缺点就是搭建过程比较麻烦，且要清楚一些概念才知道自己在做什么，因此对新手来说有一定的难度。</p>

<p>另外，让我暂时没采用这种的方案的原因是CopSSH已经不再免费了（找到一个免费的版本<a href="http://sourceforge.net/projects/sereds/files/Copssh/3.0.3/">Copssh 3.0.3</a>，需要将<a href="http://sea.tomsk.ru/pub/soft/git/Copssh_3.0.3_Installer/">icwbase-2.0.3-patch-100.exe</a>这个补丁拷贝到Copssh的安装目录下运行来修复回退键和左右方向键不能正常的问题），对于喜欢开源软件的我来说，还是希望能够找到其他的开源软件来代替。</p>

<p>关于这种方案的几篇文章：</p>

<ul>
<li><p><a href="http://www.codeproject.com/Articles/296398/Step-by-Step-Setup-Git-Server-on-Windows-with-CopS">Step by Step Setup Git Server on Windows with CopSSH + msysGit and Integrate Git with Visual Studio</a></p></li>
<li><p><a href="http://www.timdavis.com.au/git/setting-up-a-msysgit-server-with-copssh-on-windows/">Setting up a Msysgit Server with copSSH on Windows</a></p></li>
<li><p><a href="http://www.cnblogs.com/Yinner/archive/2011/05/01/2034147.html">如何在WINDOWS XP下使用copSSH配置GIT服务器 + TortiseGIT客户端</a></p></li>
</ul>


<p>另外，还有一种采用Gitolite来搭建的方案，可参考<a href="http://www.ossxp.com/doc/git/gitolite.html">Gitolite构建Git服务器</a>，讲的很详细。</p>

<p>无意之中，通过google发现了<a href="http://gitstack.com/">GitStack</a>，查看了官方文档，感觉不需要做什么特殊的设置就可以在Windows上搭建Git服务器，并且对用户权限的设置也很简单，故决定下载下来试用一下，测试下来果然很方便，且在Client端也成功进行了clone和push等操作（虽然中间遇到一个问题，后面会提到）。</p>

<p>为了以后有个参考，特在此记录下用GitStack搭建Git服务器的主要过程。</p>

<p>工具列表：</p>

<ul>
<li>服务器端：<a href="http://gitstack.com/download/">GitStack 1.4.1</a>，GitStack中已经集成了Git，可以不用再独立安装msysgit</li>
<li>客户端：<a href="http://code.google.com/p/msysgit/downloads/list">msysgit 1.7.10</a></li>
</ul>


<h3>下载并安装GitStack</h3>

<p>到其<a href="http://gitstack.com/">官方网站</a>上下载最新版的<a href="http://gitstack.com/download/">GitStack 1.4.1</a>。</p>

<p>安装文件有100M，要注意的是，目前GitStack只支持下面几个系统（不支持Windows XP）：</p>

<ul>
<li>Windows Server 2008</li>
<li>Windows Server 2008 R2</li>
<li>Windows Vista</li>
<li>Windows 7</li>
</ul>


<p>另外，GitStack是一个新的开源软件（可以看看<a href="http://gitstack.com/category/releases/">release的历史</a>），目前有些功能可能还不是很完善，文档也不是很全面，好在GitStack并不复杂。</p>

<p>安装和普通的Windows软件一样，双击安装包自动进行安装，要注意的是最好其安装路径中不要包括空格，所以不建议安装到C:\Program Files下，默认是安装到C:\GitStack下。</p>

<p>安装好GitStack后，下面主要就是配置GitStack和仓库管理。</p>

<p>提醒一下，只需要在服务器上安装GitStack即可，其他的客户机上是不要安装的。安装好GitStack后，可以在任意机器上通过浏览器登录到Git服务器上（当然实际上只有仓库的管理员才有权限登录）。</p>

<h3>GitStack的配置</h3>

<p>在服务器上，可以通过开始菜单找到GitStack打开，也可以直接打开浏览器，在地址栏里输入http://localhost/gitstack/打开登录界面。</p>

<p>另外，也可以通过server机的IP地址来登录，如server的IP地址为：192.168.0.105，则可以直接在浏览器的地址栏中输入http://192.168.0.105/gitstack/打开登录界面(注意在客户机上只能使用这种方式来打开登录界面，通过ipconfig可以查看本机的IP地址)。</p>

<p>初始状态下，默认的登录账户为admin，登录密码也为admin。管理员登录后可在Settings->General中修改admin的登录密码。</p>

<p>勾选Enable web based repository browsing选项开启在浏览器中直接查看Git仓库的内容。</p>

<p>另外还有两个Repositories和Users &amp; Groups两个界面，其中在Repositories中可以在服务器上创建项目的裸仓库，直接输入仓库名（如输入ProjectRepos），然后点击Create按钮即可（会在服务器C:\GitStack\repositories下创建一个ProjectRepos.git裸仓库），创建好的仓库也会在Repositories中显示出来，并显示出该仓库的clone的地址git clone http://localhost/ProjectRepos.git，之后就可以在Action下通过浏览器查看仓库、添加用户/Group并设置用户/Group权限等。</p>

<p>在Users &amp; Groups中，Users下是用来创建用户或修改用户密码等，每个用户对应一个Username和其Password，已有的用户会在上面的列表中显示出来；Groups下用于创建组，可以在每个Group下添加或移除用户，已有的Group也会在列表中显示出来。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/7163525050/" title="Flickr 上 shanewfx 的 gitstack_1.5"><img src="http://farm9.staticflickr.com/8164/7163525050_4e0a696de9.jpg" width="500" height="370" alt="gitstack_1.5"></a></p>

<h3>牛刀小试</h3>

<p>上述已经在服务器上创建了一个ProjectRepos.git裸仓库，现在我们在服务器上来克隆该仓库。
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd d:
</span><span class='line'>mkdir project
</span><span class='line'>cd project
</span><span class='line'>git clone http://192.168.0.105/ProjectRepos LocalRepos 或 git clone http://localhost/ProjectRepos LocalRepos 或 git clone http://localhost:80/ProjectRepos LocalRepos</span></code></pre></td></tr></table></div></figure></notextile></div>
默认的是80端口，可以修改为其他端口。
这里，会提示输入用户名和密码，注意输入的用户名和密码不会被显示出来。</p>

<p>cd LocalRepos
进入了工作目录，我们可以添加文件到工作区，并提交到本地仓库中。</p>

<p>然后，将本地修改推送到服务器的仓库里：git push origin master，这里会提示输入用户名和密码，注意输入的用户名和密码不会被显示出来。
通过git remote -v，我们可以查看origin对应的服务器上的仓库地址。</p>

<p>这时打开GitStack，可以看到服务器上仓库有了提交的内容。</p>

<h3>在客户机上克隆服务器的仓库到本地</h3>

<p>先在客户机上安装msysgit 1.7.10。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd d:
</span><span class='line'>mkdir project
</span><span class='line'>cd project
</span><span class='line'>git clone http://192.168.0.105/ProjectRepos LocalRepos</span></code></pre></td></tr></table></div></figure></notextile></div>
这里，会提示输入用户名和密码，注意输入的用户名和密码不会被显示出来。</p>

<p>cd LocalRepos
进入了工作目录，我们可以添加文件到工作区，并提交到本地仓库中。</p>

<p>然后，将本地修改推送到服务器的仓库里：git push origin master，这里会提示输入用户名和密码，注意输入的用户名和密码不会被显示出来。
通过git remote -v，我们可以查看origin对应的服务器上的仓库地址。</p>

<p>这时打开GitStack，可以看到服务器上仓库有了提交的内容。</p>

<p>在客户机上也可以打开GitStack，直接在浏览器的地址栏中输入http://192.168.0.105/gitstack/打开登录界面，当然这需要知道管理员密码。</p>

<p>（这里要注意的是，要保证在客户机上能够成功打开GitStack或者从服务器上克隆仓库，必须将服务器的防火墙关闭，否则在客户机上的这些操作就会失败。这个问题一直困扰了我好几个小时。）</p>

<p>可见，服务器和客户机在操作上已经没有什么区别了，这正是Git作为分布式版本控制系统的体现。</p>

<p>（全文完）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git常用命令的使用情景]]></title>
    <link href="http://shanewfx.github.com/blog/2012/04/28/git-command-note/"/>
    <updated>2012-04-28T13:43:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/04/28/git-command-note</id>
    <content type="html"><![CDATA[<p>在<a href="http://shanewfx.github.com/blog/2012/04/21/learn-git-command/">上一篇</a>已经大概讲了一下Git中的常用命令，本文希望能够在此基础上再做些总结，以结束Git第一阶段的学习。</p>

<p>本文尽量指出在不同情景下如何选择合适的Git命令来达到自己的目的，当然，由于Git太过强大、灵活，有时同一问题可以有多种不同的解决方案，这里不太可能全部列出，只会选择一些自己测试可用的方法。</p>

<p>文中会稍微谈一些Git内部实现的细节，但不会太具体，同时这些内容大部分是基于自己在学习过程中的一些理解，所以也不能保证相关的解释一定是正确的。</p>

<p>如发现有误，请告之，在此谢过!</p>

<!--more-->


<h2>1. 工作的开始 --创建Git仓库</h2>

<p>Git仓库的创建通常有如下几种情况：</p>

<ul>
<li>在项目的开始阶段创建Git仓库，这时，项目刚开始，使用项目中的文件都没有被纳入Git仓库中</li>
</ul>


<p>进入项目的根目录，直接执行<code>git init</code>，这样就在根目录下创建了Git仓库，表现就是在根目录下多了一个隐藏的.git目录，它对应的就是git仓库。</p>

<ul>
<li><p>如果项目已经进行了一段时间或者是之前的项目想使用git进行版本管理，这时要创建Git仓库，也是直接到项目的根目录下，执行<code>git init</code>即可</p></li>
<li><p>如果项目是多人协作，通常需要一个中心服务器来协作多人之间的工作成果</p></li>
</ul>


<p>在中心服务器上通常是创建一个裸仓库（没有工作目录），方法是执行在项目根目录下执行<code>git init --bare</code>。</p>

<ul>
<li>如果项目已经使用了git，且已经放到了中心服务器上，这时，有新人要参加该项目，他要开始工作，就需要使用<code>git clone</code>从中心服务器上获得该项目的git仓库</li>
</ul>


<h2>2. 为当前工作区做文件快照</h2>

<p>我们在工作目录中进行工作，然后需要将工作区中文件的变化情况告诉git。git与其他的版本控制系统的区别在于如果工作区的文件改动过，则git会在提交前进行一次文件快照，记录当前工作目录下所有文件和文件夹的拓扑结构及内容。为了效率和节省空间，内容相同的文件在git仓库中只会有一个blob对象来保存其内容，对于变化的文件，git会在内部创建新的blob对象，而没有变化的文件则在快照中引用之前仓库中的blob对象，这样，从每一次的提交中我们就能够知道当时工作区中文件和目录的情况。而其他版本控制系统则是保存文件的差异。</p>

<p>在工作区，文件的状态一般有如下几种：</p>

<ul>
<li>未跟踪的文件：新增加的文件或之前没有提交到git仓库的文件且没有加到.gitignore文件中</li>
<li>已修改未暂存：已经纳入git仓库，在工作区被修改的文件，但还没有进行文件快照</li>
<li>已暂存等待提交： 已经纳入git仓库，在工作区被修改的文件，且已经进行文件快照</li>
<li>已删除：已经纳入git仓库，在工作区中被删除</li>
</ul>


<p>给工作区进行文件快照，使用<code>git add</code>命令，常见用法有：</p>

<ul>
<li><code>git add .</code> 工作区的文件变动全部被添加到git的index file中</li>
<li><code>git add -u</code> 将工作区中已经纳入git仓库的文件变动添加到index file中，但新增加的文件不会被添加</li>
<li><code>git add file</code> 手动一个一个地将指定的文件添加到index file中</li>
</ul>


<p>要查看当前文件快照的内容，可以使用<code>git  ls-files --stage</code>命令来实现，它会列出index file中文件的blob对象id和文件名。</p>

<h2>3. 将文件快照提交到git仓库中</h2>

<p>对工作目录进行文件快照后，其修改的文件并未真正纳入git仓库，需要使用git commit命令将其真正提交保存到git仓库中。</p>

<p>每一次提交，git都会要求输入相应的commit信息，这样也便于今后能够快速找到指定的版本。</p>

<p>如果已经对工作区进行了文件快照，则直接执行<code>git commit -m "commit information"</code>, 这里用单引号或双引号都可以，如果这时没有加上-m选项，那么git会自动打开编辑器，让你输入提交信息，复杂的提交信息可以这样使用。</p>

<p>如果并没有对工作区进行文件快照，且只希望将已经纳入git管理的文件的变更提交到仓库中，这时，可以直接执行<code>git commit -a -m 'commit information'</code>，实际上，这只是将git add 和git commit两条命令合并起来执行。</p>

<p>git会为每一次的提交产生一个commit对象，该commit对象指向了当前的文件快照（由tree对象和blob对象组成），并且还会指向其前一次的commit对象，以形成commit提交历史。</p>

<p>另外，git内部有一个HEAD始终会指向当前分支最新的一次commit对象，每一次提交，HEAD也会跟着移动。</p>

<h2>4. 查看工作区的文件状态</h2>

<p>要了解当前工作区中的文件有没有被修改或有没有增加或者删除文件，都可以通过<code>git status</code>来查看，同时还能够了解到修改的文件没有被放入到index file中或者没有被提交到git仓库中。如果当前工作区中文件的变化都已经被提交到仓库中，则此时的工作区就是处于一个clean的状态。</p>

<h2>5. 将对外Release版本和内部开发版本分开</h2>

<p>对于软件开发，常常会遇到要修正bug、增加新功能等需求，为了不影响正常Release出去的版本，我们往往会希望自己修改的部分最好与之前的版本分开，这时候，使用分支是个不错的选择。在git中，分支是非常强大的，并且实现的成本的也很低，这是其他版本控制系统无法比拟的。灵活使用git的分支，可以帮助我们实现比以往更好、更简单的开发管理。</p>

<p><code>git branch</code>可以列出当前git仓库中已经存在的分支名；知道分支名，我们可以使用<code>git checkout 分支名</code>将工作区切换到指定的分支，这样我们就可以在这个分支上进行开发或者修正bug等工作，同时，在该分支所作的改动不会影响到其他分支。</p>

<p>要创建新分支，可以实现<code>git branch 新分支名</code>来创建，但此时并不会自动切换到新创建的分支，需要继续使用<code>git checkout 分支名</code>来切换。</p>

<p>如果想在创建分支后自动切换到该分支的话，则可以使用<code>git checkout -b 新分支名</code>。</p>

<p>上述的分支创建都是默认基于当前所在分支来创建新的分支，因此，创建并切换到新分支后工作区的文件和之前是一样的。</p>

<p>如果想基于某个指定的版本来创建分支，则需要在创建时明确地指出希望是基于哪个起点来建立新分支，这个起点可以是某个分支的最新commit，某次commit或者指定的tag等，即<code>git checkout -b 新分支名 [分支的起点]</code>。</p>

<p>在切换分支时，如果当前所在分支的工作区有文件被改动，则必须将这些改动提交到仓库或者使用git stash将当前分支状态暂时保存起来，否则分支切换就会失败。</p>

<p>当开发分支的功能已经完成，则可以将最新成果合并到主分支或者release分支。</p>

<p>要合并开发分支，需要先将分支切换到主分支或release分支，然后执行<code>git merge 开发分支名</code>来完成。</p>

<p>如果开发分支的修改是在主分支增加内容，不修改之前的内容（可以增加新文件但没有删除文件、同一文件没有修改之前的内容）时，这时合并应该是成功的（新增的部分自动合并在一起）且自动提交到git仓库中。如果同一文件在同一行的同位置有变动，则这时合并就发生的冲突（git会指示出哪个文件有冲突），自动合并过程被中止，这时就需要我们手动打开有冲突的文件（有冲突的部分可以git会在文件中加上特殊的符号标示出来，具体可以使用<code>git help merge</code>查看相关文档），并自己决定如何两个分支的内容。冲突解决后，需要自己提交到仓库中。</p>

<p>如果冲突的内容比较多时，我们可以借<code>助git mergetool</code>打开配置的工具来协作解决冲突。</p>

<p>分支合并完成后，我们可以使用<code>git branch -d 分支名</code>删除不需要的分支，要使该命令执行成功，应保证要被删除的分支已经被其他分支合并，否则会失败。如果要强制删除，不管该分支有没有被合并，则应该使用<code>git branch -D 分支名</code>，这种情况通常是用于删除那些试验失败的分支。</p>

<p>要查看分支，除了在Bash中使用<code>git branch</code>来列出已存在的分支，还可以使用<code>gitk</code>命令打开图形界面比较直观的查看各分支的提交历史和分支间的相互关系。</p>

<h2>6. 误操作的撤销</h2>

<p>在git中，各种命令的执行会影响到工作区、暂存区、git仓库三者的状态。</p>

<p>如果发生了误操作，想撤销这个操作，并恢复到某个希望的状态时，这时就需要使用<code>git reset</code>命令了。</p>

<p>如果工作区中的一些文件被修改，并且已经暂存到index中（还未提交），这时发现有些文件的修改还未真正完成，想撤销之前的git add并在工作区中保留这些文件之前的修改内容时，我们<code>git reset --mixed HEAD</code>，这时index中内容和HEAD对应的index内容一致，但工作区还是我们修改后的状态，用<code>git status</code>会显示这些文件的状态时已修改未暂存，注意此时提交并没有被撤销。（注意，--mixed是缺省的选项，因此<code>git reset HEAD</code>和<code>git reset --mixed HEAD</code>是等同的）</p>

<p>对于上述情况，如果仅仅是要index中撤销某个文件，可以使用<code>git checkout -- file</code>来完成。</p>

<p>如果上述已经提交，想撤销最近一次的提交，则可以使用<code>git reset --mixed HEAD^</code>，这时commit和index都被恢复到HEAD之前的一次提交状态，但工作区没有改变。</p>

<p>如果仅是想撤销最近一次的提交，但想保留当前index和工作区的状态，则使用<code>git reset --soft HEAD^</code>，而git reset --soft HEAD执行后，commit、index、work tree的状态都没有改变，因此，没有实际意思。</p>

<p>如果想将commit、index、work tree的状态都恢复到前一个版本的状态，则可以使<code>git reset --hard HEAD^</code>，这时要注意的是之前的所有修改被被丢弃，因此，这条命令使用时要确保当前的修改已经被提交到仓库中或者确定要放弃这些修改。另外，从这里也可以看出，使用<code>git reset --hard 指定的版本ID</code>可以将指定的版本的code从仓库中取出来查看。</p>

<p>如果发现提交时，填写的提交信息有误，则可以使用<code>git commit --amend</code>来修改；另外，如果发现提交时，漏掉某些文件，并希望将这些文件也追加到上次的提交中，可以先使用<code>git add .</code>将这些文件先暂存起来，然后使用<code>git commit -amend</code>来完成提交。</p>

<h2>7. 查看提交历史</h2>

<p>在git中，每一个提交在git仓库中都会有相应的历史记录，这样就便于我们今后在需要的时候来查看，例如，我们想知道某个版本对应的commit对象ID，这样我们就可以恢复到这个版本来查看这个版本的状态。</p>

<p>通过git log可以查看所有分支所有的提交历史信息。这些信息中，主要包括commit对象id、提交人的信息和提交时间、提交时附加上的提交信息等。</p>

<p>在经过一段时候后，可能分支上已经有很多次提交，这样git仓库中保留的历史也很多，因此，在查看时，我们需要经过一些过滤来选出我们需要的内容。</p>

<p><code>git log -p</code>会显示出每次提交做了哪些改动，<code>git log -3</code>只列出最近三次的提交历史，<code>git log --pretty=format:"%H : %s"</code>只列出每次提交的ID和提交信息，
<code>git log --graph</code>会以图形化的方式显示各分支的提交历史，<code>git log commit1..commit4</code>列出commit1和commit4之间的提交历史(不包括commit1，但包括commit4)，<code>git log commit1...commit4</code>列出commit1和commit4之间的提交历史(不包括commit1和commit4)。</p>

<p>上述的选项可以组合起来使用，如<code>git log -5 --graph</code>就会以图形的方式显示最近5次的提交历史。</p>

<p>更多的git log的选项的使用方法请使用git help log来查看。</p>

<p>另外，用<code>git show</code>可以查看指定的某次提交历史，通过<code>git reflog</code>可以查看HEAD曾经指向的commit对象的ID。它们的详细用法请查看其帮助文档。</p>

<p>通过<code>git shortlog -s -n</code>会显示出总的提交次数。</p>

<h2>8. 通过commit对象来查看该版本的文件快照内容</h2>

<p>如果我们想看看指定版本的文件快照内容，则我们需要先知道该版本的commit对象的ID。</p>

<p>通过<code>git log</code>或<code>git reflog</code>来找出指定版本的commit对象的ID。</p>

<p>通过<code>git cat-file -t ID</code>来确认该对象的类型：commit（提交）、tree(目录)、blob（文件）、tag（标签）。</p>

<p>通过<code>git cat-file commit commit-ID</code>来查看commit对象的内容，主要包括：tree对象、前一个commit对象、提交人信息、提交附加信息等，其中，tree对象就是文件快照的根目录。</p>

<p>通过commit对象知道了文件快照根目录对应的tree对象，使用<code>git ls-tree tree-id</code>来查看tree对象的内容，主要包括：其他tree对象、blob对象。</p>

<p>知道了blob对象，我们就可以通过<code>git cat-file blob blob-id</code>来查看文件的内容。</p>

<p>note：git的这些内部对象都存储在.git/object目录下，其中，每个对象用其ID前2个字符作为存储该对象的文件夹名，并在该文件夹下使用其ID剩余的38个字符作为存储该对象的文件名，这个文件就是真正存储对象内容的地方，其中的内容时被压缩过的，需要使用上述的git命令来查看。如果执行过git gc，.git/object目录下的文件会被压缩存放到.git/object/pack和.git/object/info目录下。通过find可以列出.git目录下所有目录和文件，这样就可以清楚地知道当前仓库的目录结构。</p>

<p>要查看当前分支的index内容，使用<code>git ls-files --stage</code>，它列出了文件名及对应的blob对象的ID。</p>

<p><code>git ls-files</code>根据不同的选项可以查看到文件，如将工作目录中的某些文件误删除了，这时可以使用<code>git ls-files -d |xargs git checkout --</code>即可恢复这些被删除的文件。</p>

<h2>9. 给每个release版本打上标签(里程碑)</h2>

<p>通常情况下，每个release版本都会有一个版本号与之对应，在git中，我们可以将该版本号作为tag来代表某个正式的release版本。这样的方便之处在于，以后我们可以通过tag快速定位到指定的版本，而不需要通过在冗长的提交历史中慢慢查找。</p>

<p>通过<code>git tag</code>可以列出仓库中所有的tag，要为当前分支最近一次的提交（HEAD）创建新的tag，使用<code>git tag [-a] 标签名 -m "附加信息"</code>，这样以后就可以用该标签名来代替当前分支的这次提交commit对象的ID。</p>

<p>要删除某个tag，使用<code>git tag -d 标签名</code>即可。</p>

<p>note：在想远程仓库push时，tag并不会自动被push到远程仓库中，需要自己手动去push，如<code>git push origin v1.0.0.1</code>。</p>

<h2>10. 与中心服务器的交互</h2>

<p>如果我们本地机器上没有某个项目的仓库，但中心服务器上已经有项目的仓库，我们可以用<code>git clone 中心服务器上仓库地址 本地文件夹</code>来从中心服务器上克隆一份项目的仓库，并在工作目录中进行开发工作。</p>

<p>如果我们本地机器上已经有了项目的仓库，则要从服务器上抓取最新的内容，可以使用<code>git pull</code>或者<code>git fetch</code>来实现，区别是git pull会将服务器上抓回来的内容与本地分支进行合并，而git fetch则不会进行合并。</p>

<p>在我们本地完成工作，需要将最新的成果放到服务器上时，我们可以使用<code>git push</code>来实现。</p>

<p>上述的操作都需要事先知道服务器上项目仓库的地址，并使用<code>git remote add</code>保存在本地并起了个别名，这样以后就可以直接使用别名来代替服务器上项目仓库的地址。</p>

<ul>
<li>查看本地已经添加的远程仓库： git remote仅显示已添加的远程仓库名，git remote -v可以一并查看远程仓库的地址</li>
<li>在本添加远程仓库： git remote add 远程仓库名 远程仓库地址</li>
<li>删除本地添加的远程仓库： git remote rm 远程仓库名</li>
<li>重命名远程仓库名： git remote rename 原名 新名</li>
<li>克隆远程仓库到本地： git clone 远程仓库地址 [克隆到指定文件夹]</li>
<li>从远程仓库抓取最新数据到本地但不与本地分支进行合并： git fetch 远程仓库名</li>
<li>从远程仓库抓取最新数据并自动与本地分支进行合并： git pull 远程仓库名 本地要合并的分支名</li>
<li>将本地仓库推送到远程仓库中： git push 远程仓库名 本地分支名</li>
<li>查看远程仓库信息： git remote show 远程仓库名</li>
<li>将标签推送到远程仓库： git push 远程仓库名 标签名, 默认Git是不会将标签推送到远程仓库的</li>
</ul>


<h2>11. 比较差异</h2>

<p>在实际工作中，对比文件在不同版本中有何差异是经常发生的事情。</p>

<p>在git中，我们可以通过<code>git diff</code>来比较工作区和index、index和git仓库、工作区和git仓库、不同版本同一文件等之间的差异。</p>

<ul>
<li><code>git diff</code>  比较了工作区与index的差异</li>
<li><code>git diff HEAD</code>   比较了工作区与仓库中最近一次的提交间的差异</li>
<li><code>git diff --cached</code>   比较了index与仓库中最近一次的提交间的差异</li>
<li><code>git diff HEAD^ HEAD</code>   比较了当最近的这次提交与上一次提交之间的差异</li>
<li><code>git diff 指定的分支</code>  比较了当前分支的HEAD与指定分支的HEAD之间的差异</li>
<li><code>git diff 分支1..分支2</code>  比较了分支1到分支2之间的变动</li>
</ul>


<p>更复杂的比较可以使用<code>git difftool</code>打开配置的diff工具来进行对比，上述的选项或参数也同样适用于git difftool，如<code>git difftool HEAD^ HEAD</code>。</p>

<h2>12. 紧急任务支援时保存当前分支的工作状态</h2>

<p>如果正在一个develop分支上正在开发新功能，但这时master分支(稳定版本)突然发现了bug，并需要及时修复，而develop分支此时的工作还没有完成，且不希望将之前的工作就这样提交到仓库中时，这时就可以用git stash来暂时保存这些状态到Git内部栈中，并用当前分支上一次的提交内容来恢复工作目录，然后切换到master分支进行bug修复工作，等修复完毕并提交到仓库上后，再使用<code>git stash apply [stash@{0}]</code>或者<code>git stash pop</code>将工作目录恢复到之前的状态，继续之前的工作。</p>

<p>同时也可以多次使用<code>git stash</code>将未提交的代码压入到Git栈中，但当多次使用'git stash'命令后，Git栈里将充满了未提交的代码，这时候到底要用哪个版本来恢复工作目录呢？<code>git stash list</code>命令可以将当前的Git栈信息打印出来，我们只需要将找到对应的版本号，例如使用<code>git stash apply stash@{1}</code>就可以用版本号为stash@{1}的内容来恢复工作目录。</p>

<p>当Git栈中所有的内容都被恢复后，可以使用<code>git stash clear</code>来将栈清空。</p>

<h2>13. 不同分支都在提交时，开发分支合并主分支内容，且不影响主分支</h2>

<p>假设master和develop是一个项目的两个分支，其中master是主分支，develop是从master而来的开发分支，如果在develop分支上提交过2次，之后又切换到master分支，做了一些修改并提交2次，这时，如果想将master分支的最新修改内容合并到develop分支，但同时也不能影响master分支时，就需要使用git rebase了，这时的上游分支为master。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>执行git rebase master前：&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>          develop: 1 --&gt; develop: 2
</span><span class='line'>        /
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>master: 0 --> master: 1 --> master: 2&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>执行git rebase master后：&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                                develop: 1 --&gt; develop: 2
</span><span class='line'>                               /
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>master: 0 --> master: 1 --> master: 2</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>14. 查看文件是何时被何人修改的</h2>

<p>如果找到某个版本出现了问题，而之前的版本没问题，我们可以用git blame找出文件是何时被何人怎么修改的。
<code>git blame [-L 行号1， 行号2] file</code></p>

<h2>15. 备份工作区的所有文件</h2>

<p><code>git archive --format=zip -o arch.zip HEAD</code> 或 <code>git arch --format zip head&gt;arch.zip</code></p>

<p>只备份了当前工作区的所有文件，不包括.git目录，会在工作目录中生成一个arch.zip文件。</p>

<h2>16. 查找问题是在哪个版本被引入的</h2>

<p>如果我们发现有个问题在某些版本没问题，而在有些版本有问题时，我们可以借助git bisect来帮助我们定位问题。
<code>git bisect start</code>
<code>git bisect good commit-id1</code>
<code>git bisect bad commit-id2</code>
这时，git会按照二分法找出good版本和bad版本中间的那个提交版本，并自动将工作状态切换到那个版本，这时我们可以验证这个版本是不是有问题，如果有问题，通过<code>git bisect bad</code>告诉git，这时git会继续找出一个中间版本让我们来验证，直到我们找出，并通过<code>git bisect good</code>告诉git为止。</p>

<p>这样一步一步我们就可以找出引入问题的版本，最后，我们可以使用<code>git bisect reset</code>结束查找，git会删除查找过程中在仓库中生成的临时文件，并将状态恢复到。</p>

<h2>17. 养成定期清理垃圾的习惯</h2>

<p>执行<code>git gc</code>，git会帮助我们清除仓库中垃圾，释放一些空间，并以pack的压缩方式存储对象内容，其中，.git/refs目录中内容和.git/objects目录下的对象文件会被压缩存放到.git/objects/pack目录下，而在.git/objects/info目录下会有一个packs文件用于指向.git/objects/pack目录下的一个pack文件，而这个pack文件应该是存放压缩分支、tag等信息后的文件。</p>

<p>(全文完)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git学习笔记]]></title>
    <link href="http://shanewfx.github.com/blog/2012/04/21/learn-git-command/"/>
    <updated>2012-04-21T13:39:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/04/21/learn-git-command</id>
    <content type="html"><![CDATA[<p>前一段时间在<a href="https://github.com/">Github</a>上用<a href="https://github.com/imathis/octopress">Octopress</a>搭建了博客，从此，就需要和<strong>Git</strong>不断打交道，虽然用到的Git命令不是很多。</p>

<p>刚好，这几天x64移植项目告一段落，有了点空闲时间，想想还是系统地去学习一下Git吧。</p>

<p>当然，学习Git，我也希望在今后的开发中能够用Git来管理自己的Code，结束之前那种最原始的、靠每天备份的笨方法。</p>

<p>关于Git的教程，网上有不少，感觉用的人也挺多的，所以一般的资料和问题解决方法基本通过Google都能够获得。</p>

<p>这里，关于Git的历史、原理等不会涉及太多，主要是从自身日常管理Code这个角度去谈谈如何使用Git管理代码，让自己先达到能够熟练Git这个目标。</p>

<!--more-->


<h2>起点</h2>

<p>我学习Git的起点是从阅读<a href="http://progit.org/book/zh/">Pro Git</a>开始，感觉各种概念讲解的还是蛮清楚的，涉及Git的很多方面，是一份很不错的资料。</p>

<p>另外，<a href="http://gitbook.liuhui998.com/index.html">git community book</a>和<a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_tw/index.html">Git Magic</a>也值得参考一下。</p>

<p>还有一份<a href="http://files.cnblogs.com/phphuaibei/git%E6%90%AD%E5%BB%BA.pdf">Git使用指南</a> 作为使用Git管理Code的入门资料也是很不错的。</p>

<h2>工具</h2>

<p>我学习和使用Git的平台是<strong>Windows</strong>，所以安装一下<a href="http://code.google.com/p/msysgit/">msysGit</a>提供的安装文件即可，我安装的是<a href="http://code.google.com/p/msysgit/downloads/list">Git-1.7.7-preview20111014.exe</a>，不过目前已经更新到Git 1.7.10了。</p>

<p>安装完，就可以通过命令行工具<strong>Git Bash</strong>来使用Git了，我使用Git大多数时候是通过命令行的方式，当然在Windows下也支持图形界面的方式来使用Git，使用<strong>Git GUI</strong>就可以了。</p>

<p>不过，在Git GUI里有些特殊的功能可能没有支持，需要这些功能还是要切换到Git Bash中。</p>

<p>该工具还集成到了Windows的资源管理器中，在文件夹上右键，可以点击<strong>Git Bash Here</strong>和<strong>Git GUI Here</strong>快速启动Git并自动切换到指定的文件夹，方便了不少。</p>

<p>但有时，不知怎么突然无法通过该方法启动Git，上Google查了一下，发现是与Git相关的注册表项被修改了，可能是我使用了注册表清理工具造成的吧？</p>

<p>知道了原因，修复的方法也很简单，将下面的内容复制到一个文本文件中，保存后，将文件的扩展名修改为.reg，双击注册即可。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>REGEDIT4&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\git_shell]
</span><span class='line'>@="Git Ba&amp;sh Here"&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\git_shell\command]
</span><span class='line'>@="wscript \"C:\Program Files\Git\Git Bash.vbs\" %1"&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\git_gui]
</span><span class='line'>@="Git &amp;GUI Here"&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\git_gui\command]
</span><span class='line'>@="\"C:\Program Files\Git\bin\wish.exe\" \"C:\Program Files\Git\libexec\git-core\git-gui\" --working-dir %1"</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>值得一提的是，如果开发工具是MS Virtual Studio的话，则有另外一个Git图形界面工具<a href="http://code.google.com/p/gitextensions/">Git Extension</a>可以使用，安装之后会集成到<strong>VS2005、VS2008、VS2010</strong>中，当然脱离MS Virtual Studio也可以单独使用，其图形界面的功能比上述的Git GUI要强大不少；同时，也集成到Windows资源管理器中，可以通过在文件夹上右键进入。</p>

<p>为了更深入地了解和掌握Git，下面基本是采用Git命令才演示各种操作。</p>

<h2>Git基本概念</h2>

<p>Git作为一个版本控制软件，相比其他版本控制软件有什么不同呢？</p>

<ul>
<li><p>Git是一个<strong>分布式</strong>的版本控制系统，一般来讲，各个Git仓库没有主次之分；</p></li>
<li><p>大多数的操作可以在本地完成，事后方便时，再推送到中心服务器的仓库中；</p></li>
<li><p>采用<strong>"直接记录快照，而非差异比较"</strong>的版本控制策略，内部只关心<strong>文件数据的整体是否发生改变，而不是文件内容的具体差异</strong>（Git内部被实现为一种微型的文件系统）；</p></li>
<li><p>Git工作时就是在<strong>工作目录（工作区、work tree）、暂存区（索引、index file）、本地仓库</strong>三者之间管理文件的变化情况，Git会监视工作目录中的文件变化(增加新文件，删除文件，修改文件等)，需要我们自己手动将变化的文件添加(git add)到暂存区中（这就是文件快照），然后再提交(git  commit)到本地仓库中；上述过程，涉及Git内部的三种对象：commit对象、tree对象和blob对象，blob对象会对应的文件快照中那些变化的文件内容，tree对象记录了文件快照中各个目录和文件的结构关系，从概念上讲，tree对象和blob对象组成了文件快照，commit对象则记录了这次要提交到本地仓库的文件快照，同时也会指向上次的commit对象，它也是Git内部进行版本控制的重点（Git内部会记录各个commit对象，并用HEAD来指示当前分支中最新的commit对象），很多重要的功能，如分支、版本回溯、Git仓库内部状态等都是在commit对象基础上实现的；上述的每一个对象都对应一个独一无二的ID，该ID是一个由40个字符组成的哈希码，由SHA-1算法计算而来；Git能够通过ID的前几个字符就识别出对应的对象；</p></li>
<li><p>Git的分支功能很强大，很灵活，切换速度非常快，并且实现成本很低，这也是Git比其他版本控制软件要受欢迎的原因之一；</p></li>
<li><p>Git拥有丰富的、功能强大的命令，一个命令通过配置不同的选项可以实现不同的功能；要学好Git，关键就是要掌握这些命令，并灵活使用它们；</p></li>
</ul>


<h2>Git常用命令解析</h2>

<p>Git中有许多命令，并且每种命令都有一些功能选项可被选择，因此，在不熟悉Git这些命令的时候，查阅这些命令的使用说明是不错的选择。</p>

<p>要查询Git命令，可以使用git help 命令或者git 命令 --help的方式，它会自动打开浏览器来查看。</p>

<h3>1. Git仓库创建</h3>

<p><code>git init</code></p>

<p>在项目的开始，必须使用该命令来创建和初始化Git仓库，它会在项目的文件夹下生成一个隐藏的<strong>.git文件夹</strong>，这就是这个项目的Git本地仓库，后面所有的Git命令操作都是针对该文件夹里的内容。执行过该命令后，原来的文件夹就成为了Git的工作目录。</p>

<p><em>Note：在一个已经初始化过的文件夹下再次执行<code>git init</code>，Git并不会将之前的.git文件夹的内容清除，这应该是Git的一种保护。</em></p>

<p>.git文件夹的初始组成如下：
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.git
</span><span class='line'>   |
</span><span class='line'>   |--HEAD
</span><span class='line'>   |--description
</span><span class='line'>   |--config
</span><span class='line'>   |--[refs]
</span><span class='line'>   |----|
</span><span class='line'>   |----|--[heads]
</span><span class='line'>   |----|--[tags]
</span><span class='line'>   |--[objects]
</span><span class='line'>   |----|
</span><span class='line'>   |----|--[info]
</span><span class='line'>   |----|--[pack]
</span><span class='line'>   |--[info]
</span><span class='line'>   |----|
</span><span class='line'>   |----|--exclude
</span><span class='line'>   |--[hooks]
</span><span class='line'>   |----|
</span><span class='line'>   |----|--*.sample</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>初始状态下，Git默认处于master分支，HEAD文件的内容为ref: refs/heads/master，但在refs/heads目录下却没有master文件；而objects文件夹下则没有文件。</p>

<p>在有过一次提交后，.git文件夹就会产生变化，如增加了logs文件夹，里面记录了git各种操作产生的log，我们通过git命令，如git log, git show, git reflog等可以查看这些log内容；
产生了一个index文件，这就是暂存区对应的文件; objects文件夹下新增了很多文件夹和文件，它们实际就是文件快照（tree对象和blob对象）存放的地方；
refs/heads文件夹下这时生成了master文件，其内容就是master分支最新commit对象对应的ID；如果有其他分支，则在refs/heads文件夹下也会生成以分支名命名的文件，里面存储着该分支最新commit对象的ID。</p>

<h3>2. 文件快照</h3>

<p><code>git add .</code></p>

<p>在Git中，工作目录下文件的状态可以分为已跟踪和未跟踪两大类状态，其中，已跟踪的文件是指已经被提交到git仓库的那些文件，而未跟踪的文件是指还没被提交到Git仓库中的那些非Git忽略的文件（Git可以通过在项目根目录下产生一个.gitignore文件，在里面指定要忽略的文件类型，这样Git就不会去监视这些文件的变化），如果工作目录中已跟踪的文件被修改或者删除，或者有新的文件（包括非空文件夹）加入，则通过<code>git status</code>可以查看到Git监视到文件变化情况，然后通过<code>git add .</code>做一次文件快照，并将其存储到暂存区（index文件）中，等待被提交到Git仓库中。</p>

<h3>3. 文件快照提交至仓库</h3>

<p><code>git commit -m '本次提交文件变化的描述信息'</code></p>

<p>如果工作目录中的文件变化已经被暂存（也可以同<code>git status</code>来查看），则说明这次的文件快照可以被提交到仓库中，并一直保存。</p>

<p>提交时，需要添加一些信息，这里最好要将这次的文件变化情况描述清楚，以便以后在版本回溯时能够了解到各版本之间的差别。</p>

<p>如果工作目录中仅是已跟踪的文件被修改或被删除，则可以不用先<code>git add .</code>，直接使用<code>git commit -am "描述信息"</code>即可。</p>

<h3>4. 查看工作目录文件状态</h3>

<p><code>git status</code></p>

<p>在git命令执行后，要养成通过<code>git status</code>查看git状态的习惯，以便及时了解文件变化的情况。通过<code>git status</code>可以知道文件的状态（已修改未暂存、已删除、已修改并已暂存等待提交、未跟踪）。</p>

<h3>5. 查看提交历史</h3>

<p><code>git log</code></p>

<p>通过<code>git log</code>可以查看当前分支的所有提交历史，知道每次提交的commit对象的ID以及提交时附加的描述信息等。要显示更多的信息，需要使用其支持的选项，如<code>git log -p</code>可以将每次提交的文件变化也显示出来。</p>

<p><em>Note ： <code>git log</code>显示的内容可能会比较多，但git bash上显示不下时，最下面会有一个冒号：，指示还有更多的内容，这是通过上下箭头就可以选择内容进行查看，要退出按q键即可，要查看其他命令，按h键。</em></p>

<h3>6. 查看指定的提交对象</h3>

<p><code>git show commit-id</code></p>

<p>通过<code>git log</code>可以显示整个提交历史，而通过<code>git show commit-id</code>则可以查看指定的某次提交内存，当然<code>git show -all</code>也可以显示出提交历史，另外还可以格式化显示内容。具体请查看其help。</p>

<p><em>Note : commit-id可以是commit对象对应的ID，也可以是HEAD，分支名，tag等。</em></p>

<h3>7. 查看工作目录/暂存区/仓库之间的差异</h3>

<ul>
<li><code>git diff</code>是比较工作目录与暂存区的差异</li>
<li><code>git diff HEAD</code>则是比较工作目录与仓库中最近一次的提交间的差异</li>
<li><code>git diff --cached</code>比较了暂存区与仓库中最近一次的提交间的差异。</li>
</ul>


<h3>8. 分支的创建、删除、切换、合并、查看</h3>

<p>Git一个比较吸引人的功能就是其强大的分支和合并功能。初始状态下，Git默认的分支为master。</p>

<ul>
<li>通过<code>git branch</code>可以查看目前Git仓库中已有的分支；</li>
<li>创建分支 ：<code>git branch 新分支名 [分支起点]</code>，没有分支起点的话，则默认在当前分支的最新的提交上创建分支</li>
<li>切换分支 ：<code>git checkout 分支名</code></li>
<li>创建同时切换到新分支 ：<code>git checkout -b 新分支名  [分支起点]</code></li>
<li>合并分支到master分支 ：<code>git checkout master</code>  <code>git merge 要被合并的分支名</code>，合并过程中如果发生冲突则需要自己手动解决冲突，然后再提交。有冲突时，Git会显示哪个文件有冲突，并在冲突的文件中加上特殊的标识符号，解决完冲突后，要手动去掉这些被添加的标识符号。如果冲突比较复杂的话，最好使用其他工具来协助，通过git mergetool来启动。冲突一般是在不同的分支上对同一文件的同一位置内容进行了改动，并已提交到仓库中，这样在合并的时候就会发生冲突。</li>
<li>删除已经被合并过的分支 ： <code>git branch -d 要删除的分支</code>名，如果分支没有被合并过，该命令会执行失败</li>
<li>删除分支，不管有没有被合并过 : <code>git branch -D 要删除的分支名</code></li>
<li>用图形界面查看分支提交历史 ： <code>gitk</code></li>
</ul>


<p><strong>充分利用好分支，可以帮助我们进行很好的版本控制与管理，如何用好分支其实是门艺术。</strong></p>

<p>基于分支的版本控制模型有一篇文章进行了很好的阐述。</p>

<p><a href="http://nvie.com/posts/a-successful-git-branching-model/">A succeddful Git branching model</a></p>

<p>中文翻译：<a href="http://roclinux.cn/?p=2129">Git分支管理是一门艺术</a></p>

<p><img src="/images/blogImgs/201204/git-branch-all.png"></p>

<h3>9. 标签的添加、删除、查看</h3>

<p>标签可以在需要的地方，为某个提交对象创建别名，这样以后我们就可以通过标签来查看一些信息，创建分支等。</p>

<ul>
<li>查看标签 ：<code>git tag</code></li>
<li>创建简单的标签 ： <code>git tag 标签名</code></li>
<li>创建附加信息的标签 ： <code>git tag -a 标签名 -m '附加信息'</code></li>
<li>通过标签查看信息 ： <code>git show 标签名</code></li>
<li>删除标签 ： <code>git tag -d 标签名</code></li>
</ul>


<h3>10. 与远程仓库的交互</h3>

<p>Git相比其他版本控制软件的一个优点就是大多数的操作都可以在本地进行，而不用管远程的仓库，因为操作是在本地，且操作的数据也是在本地，所以执行的速度就会比较快。
在多人协作的项目中，就需要涉及与远程仓库交互的问题，主要是如何从远程仓库抓取最新数据合并到自己的本地分支上，将自己的最新成果分享给其他人或让别人审查等 。</p>

<ul>
<li>查看本地已经添加的远程仓库 ： <code>git remote</code>仅显示已添加的远程仓库名，<code>git remote -v</code>可以一并查看远程仓库的地址</li>
<li>在本添加远程仓库 ： <code>git remote add 远程仓库名 远程仓库地址</code></li>
<li>删除本地添加的远程仓库 ：<code>git remote rm 远程仓库名</code></li>
<li>重命名远程仓库名 ： <code>git remote rename 原名 新名</code></li>
<li>克隆远程仓库到本地 ： <code>git clone 远程仓库地址 [克隆到指定文件夹]</code></li>
<li>从远程仓库抓取最新数据到本地但不与本地分支进行合并 ： <code>git fetch 远程仓库名</code></li>
<li>从远程仓库抓取最新数据并自动与本地分支进行合并 ： <code>git pull 远程仓库名 本地要合并的分支名</code></li>
<li>将本地仓库推送到远程仓库中 ：<code>git push 远程仓库名 本地分支名</code></li>
<li>查看远程仓库信息 ： <code>git remote show 远程仓库名</code></li>
<li>将标签推送到远程仓库 ： <code>git push 远程仓库名 标签名</code>, 默认Git是不会将标签推送到远程仓库的</li>
</ul>


<h3>11. 查看所有分支的所有的commit和reset操作记录（包括已删除的commit记录）</h3>

<p>通过<code>git reflog</code>可以帮助我们获得将工作目录恢复到某个状态所需的ID(可以用HEAD@{数字}来表示对应的ID)。</p>

<h3>12. 撤销操作和版本回溯</h3>

<p>有时候，由于我们的误操作，产生了一些错误，我们发现后希望能够及时纠正这些因为误操作而产生的结果，将工作目录恢复到某个正常状态。</p>

<ul>
<li>撤销文件暂存，但还没有提交的文件： <code>git checkout -- filename</code> 或<code>git reset HEAD</code> ,修改的文件会被恢复到上次提交时的状态，修改的内容会丢失</li>
<li>版本回溯 ： [方法1] 根据分支或者标签将工作目录恢复到指定版本 : <code>git checkout 分支名或标签名</code>；
[方法2] 先通过<code>git reflog</code>找到某个版本的commit-ID，然后用<code>git reset --hard commit-ID</code>将工作目录的文件恢复到指定的版本</li>
<li>恢复工作目录中被删除的文件 (文件之前被提交到仓库中)：<code>git checkout -- filename</code> 或 <code>git checkout -f</code> 或 <code>git ls-files -d | xargs git checkout --</code></li>
</ul>


<h3>13. 备份工作目录</h3>

<p><code>git stash</code> <code>git stash list</code> <code>git stash apply</code> <code>git stash pop</code> <code>git stash clear</code></p>

<p>如果正在一个develop分支上正在开发新功能，但这时master分支(稳定版本)突然发现了bug，并需要及时修复，而develop分支此时的工作还没有完成，且不希望将之前的工作就这样提交到仓库中时，这时就可以用git stash来暂时保存这些状态到Git内部栈中，并用当前分支上一次的提交内容来恢复工作目录，然后切换到master分支进行bug修复工作，等修复完毕并提交到仓库上后，再使用<code>git stash apply [stash@{0}]</code>或者<code>git stash pop</code>将工作目录恢复到之前的状态，继续之前的工作。</p>

<p>同时也可以多次使用<code>git stash</code>将未提交的代码压入到Git栈中，但当多次使用'git stash'命令后，Git栈里将充满了未提交的代码，这时候到底要用哪个版本来恢复工作目录呢？<code>git stash list</code>命令可以将当前的Git栈信息打印出来，我们只需要将找到对应的版本号，例如使用<code>git stash apply stash@{1}</code>就可以用版本号为stash@{1}的内容来恢复工作目录。</p>

<p>当Git栈中所有的内容都被恢复后，可以使用<code>git stash clear</code>来将栈清空。</p>

<h3>14. 二分查找</h3>

<p><code>git bisect</code></p>

<h3>15. 垃圾回收</h3>

<p><code>git gc</code></p>

<h3>16. 将当前工作目录文件压缩归档（不包括.git目录）</h3>

<p><code>git archive --format=zip -o arch.zip HEAD</code> 或 <code>git arch --format zip head&gt;arch.zip</code></p>

<h3>17. 跟上游分支同步</h3>

<p><code>git rebase 上游分支名</code></p>

<p>假设master和develop是一个项目的两个分支，其中master是主分支，develop是从master而来的开发分支，如果在develop分支上提交过2次，之后又切换到master分支，做了一些修改并提交2次，这时，如果想将master分支的最新修改内容合并到develop分支，但同时也不能影响master分支时，就需要使用git rebase了，这时的上游分支为master。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>执行git rebase master前：&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>          develop: 1 --&gt; develop: 2
</span><span class='line'>        /
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>master: 0 --> master: 1 --> master: 2&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>执行git rebase master后：&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                                develop: 1 --&gt; develop: 2
</span><span class='line'>                               /
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>master: 0 --> master: 1 --> master: 2</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>18. 查看commit的次数</h3>

<p><code>git shortlog -s -n</code>会显示出总的提交次数。</p>

<h3>19. 查看仓库中commit对象、tree对象和blob对象</h3>

<p>在我们将文件提交到Git仓库后，我们可以通过每次的commit对象的ID来查看文件快照的内容。</p>

<p>具体的方法就是：</p>

<ul>
<li><p>先通过<code>git log</code>查看提交历史，选择需要查看的commit-id</p></li>
<li><p><code>git cat-file -t id</code>可以知道拥有该ID的对象是属于哪种类型：<strong>commit、tree、blob</strong></p></li>
<li><p><code>git cat-file commit id</code>可以查看到该commit对象指向的tree对象的ID</p></li>
<li><p><code>git ls-tree tree-id</code>可以查看该tree中的blob对象的ID和其他tree对象的ID（如果有）</p></li>
<li><p><code>git cat-file blob blob-id</code></p></li>
</ul>


<h3>20. 查看仓库中index文件</h3>

<p>通过<code>git ls-files --stage</code>可以查看当前分支的index文件中有哪些文件，它列出了文件名及对应的blob对象的ID。</p>

<h3>21. 查看仓库目录结构</h3>

<p><code>find</code>可以列出.git目录下所有目录和文件，这样就可以清楚地知道当前仓库的目录结构。</p>

<h3>22. 查看文件的修改历史</h3>

<p><code>git blame filename</code>可以列出该文件每次被修改的时间和内容。</p>

<h3>23. 常用的linux命令</h3>

<ul>
<li>创建文件夹 <code>mkdir</code></li>
<li>删除文件夹 <code>rmdir</code></li>
<li>查看文件列表 <code>ls</code></li>
<li>查看文件内容 <code>cat</code></li>
<li>回显 和 管道命令 <code>echo "hello" &gt;&gt; file.txt</code></li>
</ul>


<p>上述的这些命令应该能够帮助我们实现多数的版本控制需求，当然其中的每一个命令都会有一些其他的选项功能这里没有提到，希望在以后使用Git的过程中能够慢慢发掘，感受Git的强大！</p>

<p>很多内容是基于自己的理解，如有误请指正。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭Blog 学Git]]></title>
    <link href="http://shanewfx.github.com/blog/2012/02/16/bulid-blog-by-octopress/"/>
    <updated>2012-02-16T14:45:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/02/16/bulid-blog-by-octopress</id>
    <content type="html"><![CDATA[<p>想要有一个自己的独立博客是很久之前的事。</p>

<p>以前也在其他网站上写过自己的博客，但总觉得用的不顺手，感觉少了归属感，最主要是提供的界面感觉都不怎么好。</p>

<p>最近想学学<strong>Git</strong>，知道了<strong>Github</strong>，开始以为就是个代码仓库，后来才发现还提供了page服务，可以用来在上面搭建自己的<strong>独立博客</strong>。</p>

<p>在Github上搭建博客可以利用<a href="https://github.com/mojombo/jekyll/wiki">Jekyll</a>或者<a href="http://octopress.org/">Octopress</a>，Octopress是在Jekyll上建立起来的，即使没有网站设计经验的人也能够快速搭建起自己的博客。</p>

<p>Jekyll和Octopress都是利用<strong>Ruby</strong>实现的，因此在搭建自己博客的过程中难免要接触到一些Ruby的东西，嗯，这说不定也是一个让自己开始了解Ruby的契机。</p>

<p>整个博客的内容和设置都是通过Git进行版本管理的，其中当然需要了解一些基本的Git操作，其实也没有几个常用的命令。</p>

<!--more-->


<p>由于我平时的工作环境都是在Windows上，所以这次搭建博客也在Windows上完成的(我使用的OS是Windows XP)。</p>

<p>下面是我用Octopress搭建博客的过程:</p>

<h2>安装和设置Git</h2>

<p>下载<a href="http://code.google.com/p/msysgit/">Git for Windows</a>，安装完成后就可以在本地使用Git了，但要将内容放到Github上，必须先在Github上注册个账户，然后在本机使用Git创建SSH Key。</p>

<p>在Git Bash上输入命令:</p>

<pre><code>ssh-keygen -C "username@email.com" -t rsa
</code></pre>

<p>Note: username@email.com需要更换成你自己的在Github上注册的Email地址</p>

<p>这样会在用户目录(C:\Documents and Settings\UserName)下产生一个.ssh文件夹，里面为对应的SSH Keys，其中id_rsa.pub是Github需要的SSH公钥文件。</p>

<p>在Github的Account Settings里选择SSH Keys，在其中将id_rsa.pub文件里内容拷贝至
其中的Key里。</p>

<p>这样以后就可以直接使用Git和GitHub了。</p>

<h2>安装Ruby环境</h2>

<p>下载<a href="http://rubyforge.org/frs/?group_id=167">RubyInstaller</a>和<a href="https://github.com/oneclick/rubyinstaller/downloads/">DevKit</a>。</p>

<p>Octopress需要的Ruby版本为1.9.2，所以选rubyinstaller-1.9.2-p290.exe，DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe。</p>

<p>先安装RubyInstaller，然后解压缩DevKit(路径中不能有中文)。</p>

<p>在"Start Command Prompt with Ruby"命令行中进入DevKit解压缩的目录，然后运行以下命令:</p>

<pre><code>ruby dk.rb init
ruby dk.rb install
gem install rdiscount --platform=ruby
</code></pre>

<p>如果安装成功，就可以使用一些Ruby的工具了，也为后面搭建博客提供了基础环境。</p>

<h2>安装Octopress</h2>

<p>先通过Git从Github上克隆一份Octopress</p>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
</code></pre>

<p>然后安装一些依赖的工具</p>

<pre><code>cd octopress
ruby --version # Should report Ruby 1.9.2
gem install bundler
bundle install
</code></pre>

<p>安装Octopress默认的Theme</p>

<pre><code>rake install
</code></pre>

<h2>配置Octopress</h2>

<p>通过修改_config.yml来配置博客，具体可以在<a href="https://github.com/shanewfx/shanewfx.github.com">我的Github</a>上查看具体的配置内容。</p>

<h2>开始写博文</h2>

<p>通过<code>rake new_post["title"]</code>来在<strong>source/_post</strong>下创建一个新的Post，文件名如下面的格式:<strong>2012-02-16-title.markdown</strong>。</p>

<p>然后可以用VIM打开该文件，并在其中输入/编辑文章内容。</p>

<p>写文章时，可以使用<a href="http://daringfireball.net/projects/markdown/">Markdown</a>和<a href="http://octopress.org/docs/blogging/plugins/">Octopress Plugins</a>来对内容进行格式排版。</p>

<h2>预览效果</h2>

<p>在修改设置或者写完文章后，想看看具体效果，可以通过如下命令来完成:</p>

<pre><code>rake generate
rake preview
</code></pre>

<p>然后在浏览器中打开http://localhost:4000/来看一看效果。</p>

<h2>将博客部署到Github上</h2>

<p>在预览的效果符合自己的预期后，就可以通过如下命令将内容部署到Github上了。</p>

<p>第一次部署前需要先要在Github上创建一个<strong>username.github.com</strong>的repository，
然后通过<code>rake setup_github_pages</code>将自己的Blog与上述的repository关联起来。
在其过程中根据提示输入<strong>username.github.com</strong>。</p>

<p>然后就可以通过下面的命令来部署自己的博客内容至Github了:</p>

<pre><code>rake deploy
git status
git add .
git commit -a -m 'comment'
git push origin source
</code></pre>

<h2>开始浏览自己的博客</h2>

<p>在浏览器的地址栏中输入<strong>username.github.com</strong>，打开的网站就是自己的博客了，此刻一个独立博客就如此问世了!</p>

<p>以后就可以享受这种以Geek方式来写博客的生活了!</p>
]]></content>
  </entry>
  
</feed>
