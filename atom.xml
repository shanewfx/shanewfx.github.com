<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[思考的轨迹]]></title>
  <link href="http://shanewfx.github.com/atom.xml" rel="self"/>
  <link href="http://shanewfx.github.com/"/>
  <updated>2013-04-25T13:36:45+08:00</updated>
  <id>http://shanewfx.github.com/</id>
  <author>
    <name><![CDATA[Shane]]></name>
    <email><![CDATA[shanewfx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[程序员的代码编辑器--Sublime Text 2]]></title>
    <link href="http://shanewfx.github.com/blog/2013/01/06/sublime-text2-for-programmer/"/>
    <updated>2013-01-06T15:43:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2013/01/06/sublime-text2-for-programmer</id>
    <content type="html"><![CDATA[<h4>===目录===</h4>

<ul>
<li>在Windows/Ubuntu上安装Sublime Text 2</li>
<li>在Windows/Ubuntu上搭建Sublime Text 2的C/C++编译环境</li>
<li>使用Sublime Text 2编写、编译、运行C++代码</li>
<li>推荐几个程序员喜欢的Sublime Text 2插件</li>
<li>使用Sublime Text 2浏览Source Code</li>
<li>使用Sublime Text 2和Github Gist管理代码片段</li>
<li>开启Sublime Text 2中的VIM功能</li>
<li>Sublime Text 2与坚果云和HK4WIN的配合使用</li>
</ul>


<h3>0.序言</h3>

<p>元旦小长假前几天偶然中接触到<a href="http://www.sublimetext.com/">Sublime Text 2</a>， 初步使用下来感觉很不错，是又一款比较适合程序员使用的文本编辑器。</p>

<p>在Sublime Text 2之前，一直比较喜欢使用VIM和Notepad++，其中VIM主要用来查看一些源代码文件或编辑一些文本，</p>

<p>而Notepad++更多是用来替代UltraEdit查看Log文件，目前使用下来感觉还不错，搜索功能同样强大。</p>

<p>当然现在VIM还基本属于初步上手阶段，主要是VIM需要记忆的命令太多，而自己在Windows上使用VIM的频率也不怎么高。</p>

<!--more-->


<h3>1.在Windows/Ubuntu上安装Sublime Text 2</h3>

<p>到<a href="http://www.sublimetext.com/2">Sublime Text 2官网</a>上下载Sublime Text 2，目前的版本是2.0.1。</p>

<p>Windows上我下载的是portable版本，解压后即可运行，这样我结合同步工具就可以再多台机器上共享Sublime Text 2的配置和插件了。</p>

<p>Ubuntu我是通过在虚拟机VirtualBox中安装的，版本是10.04，虽然版本旧了一点，但相对于新版的UI，我还是喜欢这版的。</p>

<p>Ubuntu上下载Sublime Text 2的Linux 32Bit版本即可，解压后即可运行。</p>

<h3>2.在Windows/Ubuntu上搭建Sublime Text 2的C/C++编译环境</h3>

<p>这里C/C++编译器使用的是gcc/g++。</p>

<p>在Windows上使用gcc/g++，可以安装<a href="http://www.mingw.org/">MinGW</a>，安装时要勾选上g++，默认没选择g++，安装好后需要在系统环境变量<strong>Path</strong>中加上<code>C:\MinGW\bin</code>，这里是假设MinGW被安装在C盘中。</p>

<p>打开Windows的命令控制台，输入<code>g++ -v</code>来查看g++是否安装成功。</p>

<p>当然在Windows中也可以使用VC++中的编译器，如何在命令行下使用VC++编译器请自行google之。</p>

<p>如果在命令行下可以使用VC++编译器，这样我们可以在Sublime Text 2中新建一个C++编译配置，以实现在Sublime Text 2中使用VC++编译器。</p>

<p>在Ubuntu下安装gcc/g++，在终端命令行中执行<code>sudo apt-get install build-essential</code>即可。</p>

<p>Windows下，要在Sublime Text 2中实现编译、运行C/C++代码，需要修改或新建一个C++编译配置。</p>

<p>具体是：</p>

<p>Sublime Text 2中Tools –> Build System –> New Build System…</p>

<p>输入如下内容，并将文件保存为C++Bulider.sublime-bulid。</p>

<p>在Windows中，该文件被保存在Sublime Text 2目录下的Data\Packages\User中。</p>

<p>在Ubuntu下，该文件被保证在当前用户目录下的.Config/sublime-text-2/Packages/User中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>     "cmd": ["g++", "${file}", "-o", "${file_path}/${file_base_name}"], // For GCC On Windows and Linux
</span><span class='line'>     //"cmd": ["CL", "/Fo${file_base_name}", "/O2", "${file}"],     // For CL on Windows Only
</span><span class='line'>     "file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$",
</span><span class='line'>     "working_dir": "${file_path}",
</span><span class='line'>     "selector": "source.c, source.c++",
</span><span class='line'>
</span><span class='line'>     "variants":
</span><span class='line'>     [
</span><span class='line'>          {
</span><span class='line'>               "name": "Run",
</span><span class='line'>               //"cmd": ["bash", "-c", "g++ '${file}' -o '${file_path}/${file_base_name}' && '${file_path}/${file_base_name}'"]  // Linux Only
</span><span class='line'>               "cmd": ["CMD", "/U", "/C", "g++ ${file} -o ${file_base_name} && ${file_base_name}"]  // For GCC On Windows Only
</span><span class='line'>               //"cmd": ["CMD", "/U", "/C", "CL /Fo${file_base_name} /O2 ${file} && ${file_base_name}"]   // For CL On Windows Only
</span><span class='line'>          }
</span><span class='line'>     ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我的机器上直接使用sublime Text 2默认的C++编译配置也是正常的，应该是我之前安装了Git的原因。</p>

<p>ubuntu下也是可以直接使用sublime Text 2默认的C++编译配置的。</p>

<p>搭建好C/C++编译环境后，Sublime Text 2中编译运行C/C++代码了。</p>

<h3>3.使用Sublime Text 2编写、编译、运行C++代码</h3>

<p>如在Sublime Text 2中新一个Demo.cpp文件，在其中输入代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt;stdio.h>
</span><span class='line'>
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>     printf("hello world!\n");
</span><span class='line'>     return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>勾选Tools –> Build System –>C++或者C++Bulider，使用<code>Ctrl + B</code>编译代码，<code>Ctrl + Shift + B</code>执行程序。</p>

<h3>4.推荐几个程序员喜欢的Sublime Text 2插件</h3>

<p>和VIM、Notepad++等一样，Sublime Text 2也支持通过插件来扩展其功能。</p>

<p>Sublime Text 2中安装插件前可先安装<strong>Package Control</strong>，然后通过Package Control来查找、安装插件。</p>

<p>安装Package Control的方法是：</p>

<p>在Sublime Text 2中按Ctrl + `，调出Sublime Text 2的命令行，在其中输入如下内容后，回车即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print 'Please restart Sublime Text to finish installation'</span></code></pre></td></tr></table></div></figure>


<p>安装成功后，重启Sublime text 2，这时，在Preferences下看到Package Control了。</p>

<p>在Windows中，Package Control被安装在Sublime Text 2目录下的Data\Installed Packages中；</p>

<p>在Ubuntu中，Package Control被安装在当前用户目录下的.Config/sublime-text-2/Installed Packages中。</p>

<p>而Sublime Text 2中其他的插件，在Windows中都被安装在Sublime Text 2目录下的Data\Packages中，</p>

<p>在Ubuntu中被安装在当前用户目录下的.Config/sublime-text-2/Packages中。</p>

<p>执行<code>Ctrl + Shift + P</code>调出命令窗口,输入install，根据提示选择Package Control: Install Package;</p>

<p>稍等一下，就会弹出Sublime Text 2的插件列表，在其中选择需要的插件即可完成安装。</p>

<p>下面是几个比较适合程序员使用的Sublime Text 2插件：</p>

<ul>
<li><p>Alignment: 用于代码对齐</p></li>
<li><p>CTags: 用于方便浏览源代码</p></li>
<li><p>Git：源代码版本控制</p></li>
<li><p>Gist：Github中代码片段管理、分享工具</p></li>
</ul>


<p>要使Sublime Text 2中的CTags插件可用，需要在系统中安装CTags工具。</p>

<p>到<a href="http://ctags.sourceforge.net/">这里</a>下载CTags工具，Windows选择ctags58.zip，解压后将其中的ctags.exe拷贝到C:\MinGW\Bin下。</p>

<p>Ubuntu选择ctags-5.8.tar.gz，解压后, 在Bash中进入ctags-5.8目录，</p>

<p>通过执行<code>./configure</code>, <code>make</code>, <code>make install</code>来安装ctags。</p>

<p>安装好Gist插件后，需要修改Gist.sublime-settings这个配置文件，在username后输入Github的登陆用户名，在password后输入Github登陆密码，保存即可。</p>

<p>安装好插件后，通过<code>Ctrl + Shift + P</code>调出命令窗口，然后输入插件名，根据提示可选择相应的插件功能。</p>

<h3>5.使用Sublime Text 2浏览Source Code</h3>

<p>这里主要是利用Sublime Text 2中打开文件夹和快速搜索等功能，配合CTags插件来使用。</p>

<p>对于一个已存在的工程，可以通过Sublime Text 2的Open Folder这个功能来打开工程的全部文件，其中目录结构也同样保留，这个功能对于查看开源代码是非常有帮助的。</p>

<p>而Sublime Text 2的快速搜索功能对于定位代码中的函数、变量等是非常有帮助的，结合CTags插件使用则会更加方便。</p>

<p>使用<code>Ctrl + P</code>可调出Sublime Text 2的快速搜索界面，其功能主要包括：</p>

<ul>
<li><p>可以快速跳转到当前项目中的任意文件，可进行关键词匹配</p></li>
<li><p>用 @ 可以快速列出/跳转到某个函数</p></li>
<li><p>用 # 可以在当前文件中进行搜索</p></li>
<li><p>用 : 加上数字可以跳转到相应的行</p></li>
<li><p>可通过关键字转到某个文件同时加上 @ 来列出/跳转到目标文件中的某个函数，或是同时加上 # 来在目标文件中进行搜索，或是同时加上 : 和数字来跳转到目标文件中相应的行</p></li>
</ul>


<h3>6.使用Sublime Text 2和Github Gist管理代码片段</h3>

<p>通过<code>Ctrl + Shift + P</code>调出命令窗口，在其中输入Gist，选择Gist: Open Gist会列出Github上Gist中已存在的代码片段，选择一个可用Sublime Text 2打开查看或修改。</p>

<p>修改后通过Gist: Update File上传到Github的Gist中。</p>

<p>要增加一个新的代码片段，可在Sublime Text 2中新建一个文件并在其中放入代码片段，或打开一个已存在的文件。</p>

<p>然后使用Gist: Create Public Gist，然后输入描述文件和文件名即可。</p>

<p>这里，顺便推荐一款在<strong>Chrome浏览器</strong>中使用Github Gist的插件 &#8211; <a href="https://github.com/simplelife7/EasyGist">EasyGist</a>。</p>

<p>使用下来感觉还不错，很适合在Chrome中来管理代码片段。</p>

<p>在Google网上应用点里搜索EasyGist，选择扩展程序，然后安装即可。</p>

<p>初次使用需要登录一下。</p>

<h3>7.开启Sublime Text 2中的VIM功能</h3>

<p>通过<code>Ctrl + Shift + P</code>调出命令窗口，在其中输入Preferences，选择Preferences Settings - User</p>

<p>将打开的文件内容修改为如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>     "ignored_packages":
</span><span class='line'>     [
</span><span class='line'>     ],
</span><span class='line'>     "vintage_start_in_command_mode": true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样，在Sublime Text 2中也可以使用VIM的相关命令了。</p>

<p>如插入文本前需要使用<code>i</code>进入插入模式，用<code>Esc</code>回到正常模式中。</p>

<h3>8.Sublime Text 2与坚果云和HK4WIN的配合使用</h3>

<p>在Windows中，云同步工具一直在使用<a href="https://jianguoyun.com/">坚果云</a>，在国内算是做的不错的一个，支持多目录同步。</p>

<p>由于我使用的是Sublime Text 2的portable版，这样将Sublime Text 2放入到坚果云的同步目录中。</p>

<p>这样，我在Sublime Text 2中安装的插件和修改的相关配置都会被同步到云端，</p>

<p>这样家中的机器也会自动进行同步，然后可继续使用Sublime Text 2。</p>

<p>为了使用方便，我一直使用<a href="http://www.songruihua.com/hk4win.html">HK4WIN</a>来管理键盘快捷键。</p>

<p>在HK4WIN的配置文件中加入启动Sublime Text 2的快捷键，这样，以后启动Sublime Text 2就很方便了。</p>

<p>（完）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用MFC Custom Control实现界面的自绘]]></title>
    <link href="http://shanewfx.github.com/blog/2012/11/23/mfc-custom-control/"/>
    <updated>2012-11-23T11:45:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/11/23/mfc-custom-control</id>
    <content type="html"><![CDATA[<p>最近在做一个视频编辑的项目，其中界面部分有点复杂，负责这部分的同事使用了MFC的Custom Control来实现界面的自绘效果，目前DemoAP的初步效果已经出来，感觉还不错。</p>

<p>因为工作以来基本没有接触过UI方面的编程，加之以前也没有使用过Custom Control，这次做一个简单学习和总结，以便后用。</p>

<!--more-->


<h5>1.创建MFC工程</h5>

<p>在VS2005中创建一个基于Dialog的MFC工程，DemoUI；</p>

<h5>2.添加CMyPad类</h5>

<p>在DemoUI上右击选择Add->Class，在类向导中选择MFC Class，
再点击Add，在Class Name中填入类名，如CMyPad，选择Base class为CWnd，点击Finish，
这时自动生成MyPad.h和MyPad.cpp。</p>

<h5>3.打开DemoUI.rc，双击Dialog下的IDD_DEMOUI_DIALOG，进入对话框窗口设计界面</h5>

<h5>4.在对话框上加入一个Custom Control控件</h5>

<h5>5.设置Custom Control的属性</h5>

<p>设置如下属性，其他属性使用默认即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ID ： IDC_CUSTOM_PAD
</span><span class='line'>Class: MyDrawPad</span></code></pre></td></tr></table></div></figure>


<p>其中，这里的MyDrawPad必须与注册窗口时使用的类名一致，否则编译可通过，但无法运行。</p>

<h5>6.在CMyPad类中添加一个用于注册窗口的成员函数BOOL RegisterWndClass()</h5>

<p>具体实现为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>BOOL CMyPad :: RegisterWndClass()
</span><span class='line'>{
</span><span class='line'>       WNDCLASS windowclass ;
</span><span class='line'>       HINSTANCE hInst = AfxGetInstanceHandle ();
</span><span class='line'>
</span><span class='line'>       //Check weather the class is registerd already
</span><span class='line'>       if (!(::GetClassInfo ( hInst, MYWNDCLASS , &windowclass )))
</span><span class='line'>       {
</span><span class='line'>             //If not then we have to register the new class
</span><span class='line'>             windowclass .style = CS_DBLCLKS; // | CS_HREDRAW | CS_VREDRAW;
</span><span class='line'>             windowclass .lpfnWndProc = :: DefWindowProc;
</span><span class='line'>             windowclass .cbClsExtra = windowclass. cbWndExtra = 0;
</span><span class='line'>             windowclass .hInstance = hInst;
</span><span class='line'>             windowclass .hIcon = NULL;
</span><span class='line'>             windowclass .hCursor = AfxGetApp ()->LoadStandardCursor ( IDC_ARROW);
</span><span class='line'>             windowclass .hbrBackground = ::GetSysColorBrush (COLOR_WINDOW );
</span><span class='line'>             windowclass .lpszMenuName = NULL;
</span><span class='line'>             windowclass .lpszClassName = MYWNDCLASS;
</span><span class='line'>
</span><span class='line'>             if (!AfxRegisterClass (& windowclass))
</span><span class='line'>             {
</span><span class='line'>                   AfxThrowResourceException ();
</span><span class='line'>                   return FALSE ;
</span><span class='line'>             }
</span><span class='line'>       }
</span><span class='line'>
</span><span class='line'>       return TRUE ;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中，MYWNDCLASS是在MyPad.h中定义的宏：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define MYWNDCLASS  L "MyDrawPad"</span></code></pre></td></tr></table></div></figure>


<p>(工程属性中设置为Unicode，API会调用对应的Unicode版本，因此字符串前需加上L)</p>

<h5>7.在主对话框类CDemoUIDlg中关联自定义控件类CMyPad</h5>

<p>首先在CDemoUIDlg类中添加一个成员：<code>CMyPad m_Pad</code> ;</p>

<p>然后进行关联，方法有两种：</p>

<ul>
<li><p>在<code>CDemoUIDlg ::OnInitDialog</code>中关联：<code>m_Pad .SubclassDlgItem(IDC_CUSTOM_PAD, this)</code>;</p></li>
<li><p>在<code>CDemoUIDlg ::DoDataExchange</code>中关联：<code>DDX_Control(pDX, IDC_CUSTOM_PAD, m_Pad)</code>;</p></li>
</ul>


<p>两种方法只能用其中一种，不可同时使用。</p>

<h5>8.为CMyPad添加消息响应函数</h5>

<p>在Class View中选择CMyPad，右击打开其属性界面，选择消息一栏，选择需要响应的消息，并增加对应的消息处理函数。</p>

<p>如选择<code>WM_PAINT</code>，选择<code>&lt;Add&gt;OnPaint</code>，这样就在CMyPad中自动添加了响应WM_PAINT消息的处理函数OnPaint()。</p>

<p>简单测试一下, OnPaint函数的实现如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void CMyPad:: OnPaint ()
</span><span class='line'>{
</span><span class='line'>       CPaintDC dc ( this); // device context for painting
</span><span class='line'>       // TODO: Add your message handler code here
</span><span class='line'>       // Do not call CWnd::OnPaint() for painting messages
</span><span class='line'>       dc .DrawText ( L"test123" , CRect(0,0,100,100), DT_LEFT );
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h5>9.效果测试</h5>

<p>编译运行，即可看到在Custom Control中绘制出&#8221;test123&#8221;字符。</p>

<p>（完）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件设计的几点思考和总结]]></title>
    <link href="http://shanewfx.github.com/blog/2012/10/12/software-design-principle/"/>
    <updated>2012-10-12T19:48:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/10/12/software-design-principle</id>
    <content type="html"><![CDATA[<p>软件设计是不易的，尤其要设计出结构良好、可靠性高、又不失可扩展性和可维护性的软件更是困难的事。</p>

<p>随着项目的积累、经验的丰富，不同阶段，自己对设计的理解也是不一样的，就像看一本好书，每读一遍，对其中内容的理解往往也会不同一样。</p>

<p>下面是自己对如何设计良好软件的一点理解：</p>

<!--more-->


<p></p>

<p>1.模块/类要尽可能只做一件事，并且要把事做好（符合单一职责原则、高内聚低耦合），这样也有利于提高重用性（KISS原则、DRY原则）</p>

<p>模块/类设计的注意点：</p>

<ul>
<li><p>模块所处层次是否分明[分层设计(横行划分)]，功能是否清晰[模块化设计(纵向划分)、正交设计]</p></li>
<li><p>模块接口要仔细设计</p></li>
</ul>


<p>接口要提供哪些功能，接口函数/参数命名是否直达其意（命令查询分离原则），有什么限制，如何返回结果，是否易用，尽可能多从用户使用角度考虑接口的设计；</p>

<p>接口设计要符合“接口隔离原则”，大而全的接口往往没有多个功能分类明确的接口要灵活、易用。</p>

<ul>
<li><p>信息隐藏要做好，模块的边界(接口)要清晰，用户对模块的了解要尽可能少（最少知识原则）</p></li>
<li><p>模块内部实现要尽量符合“迪米特法则”和“契约式设计”</p></li>
<li><p>只和必要的模块产生依赖，模块之间绝不可出现循环依赖</p></li>
<li><p>一组功能相关的模块可放在一起，组成功能包，这样便于修改和维护（共同关闭原则）</p></li>
</ul>


<p>2.设计时，应权衡一下是否要考虑可扩展性(需求将来是否会变化，如果比较稳定则不用考虑，避免过度设计)</p>

<p>如何设计来保证模块/函数具备一定的可扩展性（要符合开闭原则）？</p>

<ul>
<li><p>找出可能的变化，合理抽象（封装变化），提炼接口， 针对接口编程(依赖稳定的抽象/接口)， 不依赖具体的实现</p></li>
<li><p>组合优先继承（模块之间的依赖优先考虑是否可采用组合，使用继承主要是以使用多态为目的[里氏替换原则/针对接口编程]）</p></li>
<li><p>模块之间要正交（模块间功能要尽可能不重叠）</p></li>
<li><p>高层模块和低层模块之间要符合&#8221;依赖倒置原则&#8221;和“好莱坞原则”</p></li>
</ul>


<p>高层模块提供低层模块所需的接口，高层模块实现时针对这些接口编程，不依赖低层的具体实现；</p>

<p>而低层模块需要实现这些接口，实际运行时以多态的形式为高层模块提供功能（好莱坞原则）。</p>

<p>3.层次是一种软件抽象，分层设计可提高软件的灵活性，很多设计手法，其本质都是在软件的结构中加入更多的层次。</p>

<p>如对文件操作进行封装，提供一个文件操作类来代理文件操作请求，这样可屏蔽不同操作系统下文件操作API的不同，增加可移植性。</p>

<p>但也要充分考虑到层次带来的复杂性，会增加对软件理解和维护的难度。</p>

<p>因此，要努力控制层次在三层左右，否则宁愿牺牲一点抽象（软件设计是一个权衡和选择的过程）。</p>

<p>另外，层次抽象要保持内在的一致性，一个层次内部应该只做自己应该做的事，而不要去做其他层应该做的事。</p>

<p>如在设计DirectShow Filter时，应尽量把功能层次的模块与Filter层次分开，在Filter层次中只做DirectShow框架下filter应实现的功能，</p>

<p>如媒体类型的协商、与其前端/后端filter的连接、Filter之间的数据流传递等，而不涉及具体功能逻辑部分的实现；</p>

<p>同样，功能实现层也不应该依赖DirectShow框架(如数据的输出可用回调来实现解耦)。</p>

<p>这样做的好处是，以后可单独提取出具体的功能模块，移植到其他非DirectShow框架中，即Filter层仅是一层壳而已。</p>

<p>否则，这样的剥离将难以实现，同时也会因为层次边界的模糊而影响程序的可读性。</p>

<p>4.代码实现时，要有良好的编码风格，且风格要统一，函数和变量命名要准确表达其意；</p>

<p>逻辑实现要简洁利索，避免功能大而全的复杂函数，函数实现也要尽量符合KISS原则，只负责一件事；</p>

<p>总之，要时刻考虑软件维护者的感受（说不定几个月、几年之后你就是软件的维护者呢），尽可能减少让人产生怪异的感觉。</p>

<p>即尽一切方法提供程序的可读性。</p>

<hr />

<p>附上一份关于软件设计基本原则的思维导图，以便参考。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/8079555786/" title="Flickr 上 shanewfx 的 软件设计基本指导思想"><img src="http://farm9.staticflickr.com/8464/8079555786_e74017d4f8_b.jpg" width="970" height="1024" alt="软件设计基本指导思想"></a></p>

<p>图片比较大，请移步<a href="http://tu.mindpin.com/mindmaps/54796">这里</a>直接查看原始文件。</p>

<p>(完)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[个人技术提升Roadmap]]></title>
    <link href="http://shanewfx.github.com/blog/2012/10/09/my-technology-roadmap/"/>
    <updated>2012-10-09T16:37:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/10/09/my-technology-roadmap</id>
    <content type="html"><![CDATA[<p>长假之后果然不在状态，今天抽空给自己未来的学习做了一个简单的规划，也算一个简单的总结和回顾。</p>

<p>为了便于查看，特在<a href="http://tu.mindpin.com/">MindPin</a>上绘制了一张个人技术规划的思维导图。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/8070062706/" title="Flickr 上 shanewfx 的 技术Roadmap"><img src="http://farm9.staticflickr.com/8459/8070062706_8221e32965_b.jpg" width="792" height="1024" alt="技术Roadmap"></a></p>

<p>如果图片不清晰的话，请移步<a href="http://tu.mindpin.com/mindmaps/54700">这里</a>直接查看原始文件。</p>

<!--more-->


<p>随便介绍一下<a href="http://tu.mindpin.com/">MindPin</a>，这是一个在线<a href="http://zh.wikipedia.org/zh-cn/%E5%BF%83%E6%99%BA%E5%9B%BE">思维导图</a>绘制工具。</p>

<p>使用下来感觉还是蛮不错的，UI简洁、快捷键也随手、自动保存、支持多种格式导出。</p>

<p>（完）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Ubuntu中下载编译ffmpeg的过程]]></title>
    <link href="http://shanewfx.github.com/blog/2012/09/24/compile-ffmpeg-on-ubuntu/"/>
    <updated>2012-09-24T14:06:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/09/24/compile-ffmpeg-on-ubuntu</id>
    <content type="html"><![CDATA[<p>登陆<a href="http://ffmpeg.org/download.html">ffmpeg官网的下载页面</a>可以得到使用git克隆ffmpeg源代码的地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://source.ffmpeg.org/ffmpeg.git ffmpeg</span></code></pre></td></tr></table></div></figure>


<p>在ubuntu的shell下，使用上述git命令来下载ffmpeg，下载所需的时间会有点长。</p>

<p>等ffmpeg下载完成，ubuntu上就已经存在了一份完整的ffmpeg源代码了。</p>

<p>下面就可以进行编译ffmpeg了。</p>

<!--more-->


<p>编译前我们可以使用下面命令对ffmpeg的源代码进行备份：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tar czf ffmpeg.tar.gz ffmpeg/</span></code></pre></td></tr></table></div></figure>


<p>这样就在当前目录下产生一个ffmpeg.tar.gz文件。</p>

<p>在以后需要的时候可以通过下面的命令提取出ffmpeg源代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tar xzf ffmpeg.tar.gz</span></code></pre></td></tr></table></div></figure>


<p>在编译ffmpeg之前，请先安装好基本的C/C++的编译开发环境，请参考<a href="http://shanewfx.github.com/blog/2012/09/22/study-ubuntu-on-virtualbox/">上篇文章</a>。</p>

<p>另外，ffmpeg编译时需要使用yasm，如果系统中没有安装，可以通过下面的命令来安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install yasm</span></code></pre></td></tr></table></div></figure>


<p>上述的编译工具安装好后，就可开始编译ffmpeg了。</p>

<p>ffmpeg是采用autoconfig和automake等工具自动生成makefile，然后再通过make进行编译，具体的编译的过程如下：</p>

<ul>
<li><p>使用<code>./configure</code>产生makefile文件</p></li>
<li><p>使用<code>make</code>进行编译</p></li>
<li><p>使用<code>make install</code>将ffmpeg安装到系统中</p></li>
</ul>


<p>安装ffmpeg到系统中，需要root权限，在shell下执行下面的命令切换到root账户下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo -i</span></code></pre></td></tr></table></div></figure>


<p>根据提示输入root密码，然后还需再次进入到ffmpeg源代码目录中，再执行<code>make install</code>即可。</p>

<p>默认是安装在/user/local下，其中：</p>

<ul>
<li><p>头文件放在/user/local/include目录下</p></li>
<li><p>编译好的libs放在/user/local/lib目录下，其中，在该目录下还有一个pkgconfig目录，里面存放着每个lib的配置文件</p></li>
<li><p>编译好的可执行文件(ffmpeg、ffprobe、ffserver)放在/user/local/bin目录下</p></li>
<li><p>文档在/user/local/share/man/man1目录下，同时在/user/local有一个指向此目录的链接</p></li>
</ul>


<p>后面计划研究一下ffmpeg的架构，如何抽取出ffmpeg中某个Codec，如何增加自己的Codec到ffmpeg中，以及如何基于ffmpeg开发一个简单的播放器。</p>

<p>(全文完)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在VirtualBox上小玩Ubuntu]]></title>
    <link href="http://shanewfx.github.com/blog/2012/09/22/study-ubuntu-on-virtualbox/"/>
    <updated>2012-09-22T18:08:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/09/22/study-ubuntu-on-virtualbox</id>
    <content type="html"><![CDATA[<p>第一次接触Linux应该是读研时，当时自己在实验室里捣鼓着嵌入式开发，慢慢也就了解了一些Linux的东西，不过当时完全很业余，很多东西都不太懂。</p>

<p>后来，跟其他实验室的同学借了Linux的安装光盘，在自己的机器上第一次装上Linux，不过后来好像也没什么深入的使用。</p>

<p>工作以后，一直是在Windows上做开发，基本不涉及Linux，不过自己对Linux还是蛮感兴趣的，在家里的电脑上也一直安装着Ubuntu，偶尔也会上去玩一玩。</p>

<p>随着和开源软件的接触，发现很多的开源Code都是来自于Linux，自己也一直想学习一下Linux中C/C++开发的方法。</p>

<p>由于自己大部分的工作和家人对电脑的使用都是集中在Windows上，不希望来回切换系统，故多数是在Windows上使用VirtualBox虚拟机安装Ubuntu来使用。</p>

<p>虚拟机上的Ubuntu，我只会安装Linux C/C++开发所必要的一些软件，如代码编辑器Vim, C/C++编译调试工具，代码版本控制工具Git等。</p>

<!--more-->


<p>我使用的Ubuntu版本是10.04，之前安装过11.10这个版本，不过在虚拟机上运行速度不是很好。</p>

<p>如何使用VirtualBox安装Ubuntu，请Google参考相关教程，要注意的是下载下来的Ubuntu的ISO镜像文件，最好验证一下MD5码，以确保镜像文件是完整正确的，否则安装可能会失败。</p>

<p>另外，中文拼音输入法ibus-pinyin还算比较好用，在Ubuntu软件中心搜索ibus-pinyin并安装，然后“系统->首选项->IBUS首选项”切换到输入法选项卡，添加“汉语->拼PINYIN”即可。</p>

<p>下面主要是讲一讲Linux下C/C++开发的一些话题：</p>

<ul>
<li>Linux C/C++开发环境的搭建</li>
<li>Linux常用shell命令</li>
<li>vim的基本操作</li>
<li>gcc/g++/gdb/make工具的熟悉和使用</li>
<li>makefile的编写</li>
<li>autoconf和automake自动生成makefile的方法</li>
</ul>


<h2>1.搭建Ubuntu下C/C++开发环境</h2>

<p>安装C/C++编译工具，包括gcc, g++, gdb, make等，只需要执行下面这条命令即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install build-essential</span></code></pre></td></tr></table></div></figure>


<p>使用&#8221;gcc -v&#8221;来检查一下安装是否成功。</p>

<p>安装自动生成makefile的相关工具,只需要执行下面这条命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install automake1.9</span></code></pre></td></tr></table></div></figure>


<p>这样，依赖的工具也会被安装，包括autoscan、aclocal、autoconf、automake等。
有了这些工具，在大的开发项目中，就可以不用自己去编写makefile了。</p>

<p>安装源代码编辑器Vim，会比Ubuntu原本自带的vi更好用些。
关于如何将Vim打造成一个IDE，以后再研究吧，网上也有相关的文章可参考，主要是使用Vim插件并修改Vim配置文件。
安装Vim执行下面这条命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install vim</span></code></pre></td></tr></table></div></figure>


<p>这样以后在shell下可直接使用&#8221;vim 文件名&#8221;，在当前目录下创建一个新文件并打开文件进行编辑或直接打开已存在的文件进行编辑。</p>

<p>安装源代码版本控制工具Git，只需要执行下面这条命令即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install git-core</span></code></pre></td></tr></table></div></figure>


<p>上述工具都安装成功后，在Ubuntu上就已经具备开发C/C++程序的基本环境了。</p>

<p>当然，在Linux上做开发也是有IDE可供选择的，如Eclipse、NetBeans等，据同事介绍，似乎NetBeans还算好用，和Windows下VC比较相似了，而做Android开发一般都是用Eclipse。</p>

<p>目前, 我还不打算使用这些IDE，而是想从底层学习这种在shell下用Vim编写源代码和makefile来完成Code编译和调试的开发模式。</p>

<p>这样，不但有助于掌握Vim和常用的shell命令，而且对相关编译工具的使用、makefile的编写以及理解编译的过程都是有帮助的，当然这样感觉上也会更酷。</p>

<h2>2.Linux常用shell命令</h2>

<p>Linux中的命令有很多，这里只列出在开发过程中一些比较常用的命令。
每一个命令可能都有一些选项参数可以使用，用<code>man 命令</code>或者<code>命令 --help</code>可来查看相关说明。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++
</span><span class='line'>shell命令     |      功能说明
</span><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++
</span><span class='line'>mkdir                创建目录
</span><span class='line'>rmdir                删除目录
</span><span class='line'>ls                   查看当前目录下的文件和目录(不包括隐藏文件)
</span><span class='line'>ls -a                查看当前目录下的文件和目录(包括隐藏文件)
</span><span class='line'>cd                   切换到指定目录（/表示系统根目录 ./表示当前目录 ../表示当前目录的上一级目录）
</span><span class='line'>pwd                  查看当前目录的绝对路径
</span><span class='line'>cat                  查看文件内容
</span><span class='line'>touch                修改文件日期或创建新文件
</span><span class='line'>rm                   删除文件
</span><span class='line'>mv                   移动文件或修改文件名
</span><span class='line'>cp                   复制文件或目录
</span><span class='line'>chmod                修改文件操作权限
</span><span class='line'>find                 查找文件或目录
</span><span class='line'>grep                 查找文件里符合正则表达式的字符串
</span><span class='line'>sed                  处理和编辑文本
</span><span class='line'>diff                 比较文件间的差异
</span><span class='line'>tar                  文件打包和解包，通过cvf参数打包，通过xvf解包
</span><span class='line'>zip                  压缩工具，.zip
</span><span class='line'>unzip                解压缩zip文件
</span><span class='line'>gzip                 压缩解压缩工具，.gz，通过-d参数进行解压缩
</span><span class='line'>man                  查看命令说明
</span><span class='line'>file                 查看文件类型
</span><span class='line'>which                查看命令文件安装的位置
</span><span class='line'>whereis              查找软件的安装路径
</span><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></code></pre></td></tr></table></div></figure>


<h2>3.Vim基本操作</h2>

<p>被尊称为程序员神器的Vim有着比较高的学习曲线，不过掌握一些基本的Vim命令，足以让你应付一般的文本编辑。</p>

<p>这里有一份<a href="http://coolshell.cn/articles/5479.html">Vim命令的速查卡</a>：</p>

<p><a href="http://www.flickr.com/photos/shanewfx/8011943417/" title="Flickr 上 shanewfx 的 vim"><img src="http://farm9.staticflickr.com/8296/8011943417_b813b2b38a.jpg" width="500" height="386" alt="vim"></a></p>

<p>常用的Vim操作请参考陈皓的<a href="http://coolshell.cn/articles/5426.html">简明Vim练级攻略</a>，按照攻略来练习吧。</p>

<hr />

<p>（未完待续）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[思维导图: 我的常用软件]]></title>
    <link href="http://shanewfx.github.com/blog/2012/09/06/my-favorite-software/"/>
    <updated>2012-09-06T20:20:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/09/06/my-favorite-software</id>
    <content type="html"><![CDATA[<p>一直以来，我的软件工具集中都会收藏一些比较好用的软件，尤其喜欢<strong>免费</strong>、<strong>开源</strong>的软件。</p>

<p>这里，列出我最常用的一些软件，以备后忘。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/7943007570/" title="Flickr 上 shanewfx 的 我的常用软件"><img src="http://farm9.staticflickr.com/8179/7943007570_99bc0edc27.jpg" width="427" height="500" alt="我的常用软件"></a></p>

<p>思维导图使用<a href="http://freemind.sourceforge.net/wiki/index.php/Main_Page">FreeMind</a>绘制。</p>

<!--more-->


<h2>1 Chrome浏览器</h2>

<p>在<a href="http://www.google.cn/intl/zh-CN/chrome/browser/?hl=zh-CN&amp;brand=CHMI">Chrome</a>出来之前，通常使用<strong>Firefox</strong>，有了<strong>Chrome</strong>，就再也没变过。不过，网购一般还是要回到IE的。</p>

<p>常用的Chrome插件：</p>

<p><strong>AdBlock、FaWave(发微)、Google Mail Checker、IE Tab、Google阅读器通知程序</strong>等</p>

<h2>2 云笔记Evernote</h2>

<p>以前在网上看到不错的文章一般会收藏到<a href="http://shanewfx.360doc.com">360doc</a>，自从接触了<strong>Evernote</strong>，<strong>个人知识管理</strong>就由Evernote负责了。</p>

<p>另外，我比较多的阅读时间是花在<strong>Google阅读器</strong>上，看到喜欢的文章会“加星”标识。</p>

<p>这样通过<a href="https://ifttt.com/">ifttt</a>这个网络工具就可以自动将<strong>加星的文章</strong>发送到Evernote中，因为每个Evernote账户都对应一个个人Evernote邮件地址，向这个地址发送内容会自动出现在Evernote中。</p>

<p>随着时间的推移，Evernote中的文章会越来越多，如果不加分类，以后会很难找到需要的文章。</p>

<p>因此，最好一开始的时候就建立好笔记的结构，并利用标签对文章分类。</p>

<p><a href="http://www.zhihu.com/">知乎</a>上有一些关于如何用好Evernote的讨论，可以去参考一下。</p>

<p>我的Evernote笔记分类结构：</p>

<p><a href="http://www.flickr.com/photos/shanewfx/7943205150/" title="Flickr 上 shanewfx 的 Evernote"><img src="http://farm9.staticflickr.com/8181/7943205150_d33b5b9b1e.jpg" width="219" height="500" alt="Evernote"></a></p>

<p>另外，Evernote每个月只有60M的同步流量，不过对于保存一般的文本和少量的图片是完全够用的。</p>

<h2>3 云储存（坚果云）</h2>

<p>以前要在网络上备份文件，一般都是用网络硬盘，不过一般空间都不大。</p>

<p>而如今的云计算产品是越来越多了，特别近两年，云储存的产品遍地开花，如来头大的有Google Drive、微软的SkyDrive等，我想最出名应该是非Dropbox莫属。</p>

<p>我正式使用云储存应该是今年初，开始用的是金山T盘，不过使用下来并不太满意，而且金山似乎对该产品不太重视，直到在<a href="http://xbeta.info/">善用佳软</a>的博客上看到坚果云的介绍，才慢慢转到坚果，并一直使用至今。</p>

<p><a href="https://jianguoyun.com/">坚果云</a>总体使用下来还不错，同步在背后默默进行，只需将要同步的文件放到指定的文件夹就可以了，而且速度很快。
支持多同步文件夹，同步的文件有版本控制，网页界面很简洁，感觉是用心在做这款产品。</p>

<p>不过，对于免费用户，每个月只有1G的上传流量，3G的下载流量，刚开始转过来的时候上传流量不太够用，后来就基本够用了。</p>

<h2>4 文本编辑器（Notepad++和VIM）</h2>

<p>对于文本编辑器，目前使用最多的应该是Notepad++，主要用来查看、编写一些文本文件，偶尔也会用一用VIM，主要是一些命令总是不太记得住，以后还是要好好学习一下VIM的。</p>

<p>在查看Log文件目前使用比较多的还是UltraEdit，不过慢慢应该会转到Notepad++和VIM上的。</p>

<h2>5 快捷键管理工具（HK4WIN）</h2>

<p>我现在越来越喜欢用键盘快捷键来代替鼠标操作，这样日常的操作效率会高很多。</p>

<p>一个用<strong>AutoHotkey</strong>开发的<a href="http://www.songruihua.com/hk4win.html">HK4WIN2</a>是我用来管理快捷键的主要工具，可以定制打开指定软件和文件夹等快捷键。</p>

<h2>6 版本控制（Git）</h2>

<p>正式使用Git也是今年初开始的，前面有几篇关于Git学习的文章，<a href="http://shanewfx.github.com/blog/2012/04/21/learn-git-command/">这里</a>，<a href="http://shanewfx.github.com/blog/2012/04/28/git-command-note/">这里</a>。</p>

<p>目前使用Git最多的还是来管理我的这个博客，以后慢慢会在工作中引入使用。</p>

<p>偶尔也会用SVN来下载一些开源代码。</p>

<h2>7 其他常用的软件</h2>

<p>PDF阅读，我一直使用免费小巧的<strong>Foxit Reader</strong>; 而PDF打印，则常用使用<a href="http://sourceforge.net/projects/pdfcreator/">PDF Creator</a>。</p>

<p>系统垃圾文件的清理使用<a href="http://www.piriform.com/ccleaner/download">CCleaner</a>。</p>

<p>磁盘碎片整理<a href="http://www.piriform.com/defraggler">Defraggler</a>是不错的选择。</p>

<p>文件恢复工具<a href="http://www.piriform.com/recuva">Recuva</a>值得一试。</p>

<p>文件加密非<a href="http://www.truecrypt.org/">TrueCrypt</a>莫属，非常强大。</p>

<p>文件的快速搜索<a href="http://www.voidtools.com/">Everything</a>很好用，速度非常快。</p>

<p>文件压缩和解压缩一直在使用<a href="http://www.7-zip.org/">7-Zip</a>。</p>

<p>虚拟机目前只使用过<a href="https://www.virtualbox.org/">VirtualBox</a>，操作很简便。</p>

<p>中文输入法尝试过很多，如紫光拼音、Google输入法等，目前一直在使用<a href="http://pinyin.sogou.com/">搜狗输入法</a>。</p>

<h2>8 网络工具</h2>

<p><strong>Google Reader</strong>是我每天开始阅读的地方，好的博客我会订阅在这里。</p>

<p><strong>Google gmail</strong>是我的主要邮箱，每天会收到不少邮件，对于交流的邮件我一般会即时回复。</p>

<p>微博（<strong>新浪微博</strong>和<strong>腾讯微博</strong>）是我每天了解这个社会热点事件的主要场所，在Chrome中主要是使用<strong>FaWave(发微)</strong>，很少去使用网页版。</p>

<p>偶尔会用用<strong>Google日历</strong>，重要的日子给个提醒。</p>

<p>目前Blog的图片基本是放到<strong>Flickr</strong>上，因此，<a href="http://www.flickr.com/">Flickr</a>我是做为图床来使用的。</p>

<p>(暂完)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Python图形化分析大Log文件]]></title>
    <link href="http://shanewfx.github.com/blog/2012/09/03/analyze-log-file-based-on-python/"/>
    <updated>2012-09-03T14:14:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/09/03/analyze-log-file-based-on-python</id>
    <content type="html"><![CDATA[<p>最近因为项目需要经常分析数据量很大的Log文件，以往靠手工目测的分析方法已不太可能快速分析和定位问题。</p>

<p>由于和我一起做这个项目的同事，会使用Python，编写的Python脚本能够将Log中的相关数据以图形的方式显示出来，这样就便于我们快速检测出是否输入、输出有异常情况发生。
这样，也就加快了解决问题的效率。</p>

<p>为此，在这里简要记录一下具体的方法，以便以后在需要的时候能够做参考。</p>

<!--more-->


<h2>工具准备</h2>

<p>需要的工具如下：</p>

<ul>
<li><p><a href="http://www.python.org/">Python</a>（版本是2.7.3，自带一个简单的IDE）</p></li>
<li><p>数值运算库<a href="http://sourceforge.net/projects/numpy/files/NumPy/">numpy</a>，matplotlib依赖这个库</p></li>
<li><p>类似matlab的图形库<a href="http://matplotlib.sourceforge.net/">matplotlib</a></p></li>
<li><p>文本编辑工具<a href="http://gnuwin32.sourceforge.net/packages/sed.htm">sed</a></p></li>
</ul>


<p>有了这些工具，还需要了解一些正则表达式，可参看<a href="http://shanewfx.github.com/blog/2012/09/01/learning-regex/">这里</a>。</p>

<p>当然，基本的Python脚本编程功底的需要的。网上关于Python的教程有很多，我参考了如下几篇：</p>

<ul>
<li><p><a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/">简明Python教程</a></p></li>
<li><p><a href="http://docs.linuxtone.org/ebooks/Python/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf">Python学习笔记</a></p></li>
<li><p><a href="http://woodpecker.org.cn/diveintopython/">Dive into Python</a></p></li>
</ul>


<p>从这几天学习的效果来看，Python应该算是比较容易上手的语言。</p>

<p>可能是Python里面的语法和概念和C++有相似之处，所以很多语法基本只有了解一下怎么写就可以了。</p>

<p>其中，列表、序列、字典这几种Python中的数据结构要用熟，另外，在Python中不需要再关心数据的类型，直接用就好了。</p>

<p>终于体会到一点“学好C++之后再学其他语言要相对容易”的感觉。</p>

<p>看了上述的教程，现在写一些简单的脚本也是很容易的了。</p>

<h2>分析Log文件的过程</h2>

<ul>
<li>编写批处理文件，使用Sed命令从Log文件中提取出需要的数据，将所有匹配数据所在的行都打印出来，写并到其他的文件中</li>
</ul>


<p>参考下面的代码，其中，Sed命令中引号的内容为要匹配文本的正则表达式，正则表达式在两个斜杠之间，后面的p是打印的命令，Sed命令执行的结果被重定向到后面的文件中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>del /f/s/q Video.txt
</span><span class='line'>del /f/s/q Audio.txt
</span><span class='line'>
</span><span class='line'>del /f/s/q VideoRecv.txt
</span><span class='line'>del /f/s/q AudioRecv.txt
</span><span class='line'>
</span><span class='line'>del /f/s/q videopts.txt
</span><span class='line'>del /f/s/q audiopts.txt
</span><span class='line'>
</span><span class='line'>sed -n "/Video.*New Frame/p" tsmux.txt>>Video.txt
</span><span class='line'>sed -n "/Audio.*New Frame/p" tsmux.txt>>Audio.txt
</span><span class='line'>
</span><span class='line'>sed -n "/nType : ESTYPE_VIDEO/p" tsmux.txt>>VideoRecv.txt
</span><span class='line'>sed -n "/nType : ESTYPE_AUDIO/p" tsmux.txt>>AudioRecv.txt
</span><span class='line'>
</span><span class='line'>sed -n "/origin pts: .*, video/p" tsmux.txt>>videopts.txt
</span><span class='line'>sed -n "/origin pts: .*, audio/p" tsmux.txt>>audiopts.txt</span></code></pre></td></tr></table></div></figure>


<p>这个批处理的脚本要和要分析的Log文件放在同一文件夹下，这样双击执行脚本，文件夹中会多了5个文件，这几个文件就是我们下面Python脚本需要用到的。</p>

<ul>
<li>编写分析Log数据的Python脚本，该脚本运行后会以图形的方法显示出相关数据的分析结果</li>
</ul>


<p>下面这个例子要完成的功能就是前端输入PTS的总体趋势是否正确，有无明显跳变。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import re
</span><span class='line'>import matplotlib.pyplot as plt
</span><span class='line'>
</span><span class='line'>print "analyse video input pts!..."
</span><span class='line'>
</span><span class='line'>regex  = re.compile('video pts : (\d+)')
</span><span class='line'>regex1 = re.compile('audio pts : (\d+)')
</span><span class='line'>
</span><span class='line'>video_index = []
</span><span class='line'>video_pts   = []
</span><span class='line'>
</span><span class='line'>'''
</span><span class='line'>file = open("videopts.txt", "rb")
</span><span class='line'>log = file.readline()
</span><span class='line'>while log:
</span><span class='line'>    found = regex.search(log)
</span><span class='line'>    if found:
</span><span class='line'>        video_index.append(len(video_index))
</span><span class='line'>        video_pts.append(found.group(1))
</span><span class='line'>    log = file.readline()
</span><span class='line'>file.close()
</span><span class='line'>'''
</span><span class='line'>
</span><span class='line'>file  = open("videopts.txt", "rb")
</span><span class='line'>log = file.read()
</span><span class='line'>file.close()
</span><span class='line'>
</span><span class='line'>m = regex.findall(log)
</span><span class='line'>if m:
</span><span class='line'>    print "video match success"
</span><span class='line'>    for pts in m:
</span><span class='line'>        video_index.append(len(video_index))
</span><span class='line'>        video_pts.append(pts)
</span><span class='line'>else:
</span><span class='line'>    print "not match"
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>audio_index = []
</span><span class='line'>audio_pts   = []
</span><span class='line'>
</span><span class='line'>file1 = open("audiopts.txt", "rb")
</span><span class='line'>log1 = file1.read()
</span><span class='line'>file1.close()
</span><span class='line'>
</span><span class='line'>m1 = regex1.findall(log1)
</span><span class='line'>if m1:
</span><span class='line'>    print "audio match success"
</span><span class='line'>    for pts1 in m1:
</span><span class='line'>        audio_index.append(len(audio_index))
</span><span class='line'>        audio_pts.append(pts1)
</span><span class='line'>else:
</span><span class='line'>    print "audio not match"
</span><span class='line'>
</span><span class='line'>print "begin to plot"
</span><span class='line'>
</span><span class='line'>fig = plt.figure()
</span><span class='line'>video_pts_plot = fig.add_subplot(211)
</span><span class='line'>video_pts_plot.plot(video_index, video_pts, 'r')
</span><span class='line'>audio_pts_plot = fig.add_subplot(212)
</span><span class='line'>audio_pts_plot.plot(video_index, video_pts, 'b')
</span><span class='line'>plt.show()</span></code></pre></td></tr></table></div></figure>


<p>运行这个Python脚本后，可看到输入的Video/Audio PTS以图形的方式被显示出来。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/7919967470/" title="Flickr 上 shanewfx 的 python"><img src="http://farm9.staticflickr.com/8169/7919967470_a8847583ce.jpg" width="500" height="498" alt="python"></a></p>

<p>在这个例子中，我们可以看到要使用到Python的正则表达式库re，图形绘制库matplotlib，还需要了解python中文件的操作，列表的使用等。</p>

<p>具体的用法请google其他资料。</p>

<p>（完）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正则表达式初学笔记]]></title>
    <link href="http://shanewfx.github.com/blog/2012/09/01/learning-regex/"/>
    <updated>2012-09-01T13:43:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/09/01/learning-regex</id>
    <content type="html"><![CDATA[<p>最近一直在做MPEG2 TS-Mux，在开发调试的过程中有大量的log数据需要分析，特别是长时间测试，log文件往往会达到几百兆。</p>

<p>这时遇到问题，要自己逐行去分析log定位问题往往是不太现实的事情。</p>

<p>为了提高log文件分析的效率，我们利用Python编写分析log的脚本，每个脚本分析log文件中一类信息，如从前端Encoder中接受到的PTS，分析PTS是否有错误或跳变等情况。</p>

<p>为了从原始的log文件中提取出我们关心的log部分，使用了一个命令行工具<a href="http://gnuwin32.sourceforge.net/packages/sed.htm">Sed</a>。</p>

<p>Sed(streams editor)的具体使用方法可参考这篇文章<a href="http://blog.csdn.net/cxqdong/article/details/2007884">sed命令+正则表达式</a>。</p>

<p>在一个数据量很大的文本中要查找出所有符合特定规则的文本，使用文本编辑器中简单查找功能往往很难达到要求。</p>

<p>不过现在的文本编辑器也越来越强大，我熟悉的如VIM、Notepad++、UltraEdit等都是支持使用<a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式</a>来完成复杂的、自定义规则的文本查找功能。
上述的Sed也是使用正则表达式来实现强大的文本查找功能。</p>

<p>下面将会简单介绍一些关于正则表达式的知识，以后有时间会写一篇关于如何使用Python和matplotlib库来分析log数据并图形化显示分析结果的文章。</p>

<!--more-->


<p>对于正则表达式，我基本也是属于初学，这里主要是记录一下正则表达式的基本语法，学会如何使用这些基本语法来构建符合自己查找意图的正则表达式。</p>

<p>网上关于正则表达式的教程有很多，我主要参考了如下几篇：</p>

<ul>
<li><p><a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></p></li>
<li><p><a href="http://www.regexlab.com/zh/regref.htm">揭开正则表达式的神秘面纱</a></p></li>
</ul>


<h2>什么是正则表达式?</h2>

<p>正则表达式(Regular Expression)，实际上就是一个描述待查找文本特征的字符串，这些字符串就构成了查找的规则，如下面的这些例子：</p>

<ul>
<li><p>abc                ->  描述了待查找文本的特征是：待查找的就是包含abc的文本</p></li>
<li><p>\d&#8230;\s123         ->  描述了待查找文本的特征是：以数字开关(在0至9范围内)，后面跟3个任意字符，再跟一个任意类型的空格，之后跟着123</p></li>
<li><p>[1-9][0-9]{4, 11}  ->  描述了待查找文本的特征是：以1至9范围内任一数字为开头，后面最少跟4个，最多跟11个数字(在0至9范围内)</p></li>
<li><p>\d{4}-?\d{7, 8}    ->  描述了待查找文本的特征是：以4个数字开头，中间可以有也可以没有-，后面最少跟7个，最多跟8个数字(在0至9范围内)</p></li>
</ul>


<p>如果之前没有接触过正则表达式，初次看到上述的这几个字符串，肯定不知所云，觉得莫名其妙。
没关系，我相信大多数人在开始学习正则表达式时会有这样的感觉。</p>

<p>实际上，通过上述的一些解释，我们可以看到正则表达式中使用了一些特殊的符号来表示一类字符，如使用\d来表示0至9范围内的数字等。</p>

<p>要想对正则表达式有深入了解，我们需要去学习一下正则表达式的基本语法，熟悉之后，我们就可以根据实际的需要来构建自己的正则表达式。</p>

<h2>正则表达式的基本语法</h2>

<p>注：文中的部分例子来自于<a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a>。</p>

<h3>元字符</h3>

<p>元字符是正则表达式中一种特殊的字符，是用来表示其他字符的字符，实际查找的文本并不包含自身，相当于是信息的一种描述。</p>

<p>在正则表达式中，有如下几种元字符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++
</span><span class='line'>元字符    |     描述的特征
</span><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++
</span><span class='line'>  .      |     匹配除换行符以外的任意字符
</span><span class='line'>  \w     |     匹配字母或数字或下划线或汉字
</span><span class='line'>  \s     |     匹配任意的空白符
</span><span class='line'>  \d     |     匹配数字
</span><span class='line'>  \b     |     匹配单词的开始或结束
</span><span class='line'>  ^      |     匹配字符串的开始
</span><span class='line'>  $      |     匹配字符串的结束
</span><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></code></pre></td></tr></table></div></figure>


<h3>转义字符</h3>

<p>元字符是用来表示其他的字符，而不能用来表达自身，因此，如果我们查找的文本中的确是要包含元字符时，这时就需要使用转义字符。</p>

<p>熟悉C/C++的同学应该对转义字符会很熟悉，转义字符就是使用反斜杠&#8217;&#39;来取消元字符的特殊意义，而表达自身的一种方法，类似上述元字符中的\w,\s,\d,\b。</p>

<p>上述的这几个在形式上类似转义字符的元字符在实际中是不需要转义的，因为它们相当于是2个字符，而如果要查找的文本中要包含., ^, $，则需要转义., \<sup>,</sup> \$。</p>

<h3>指定重复的次数</h3>

<p>在正则表达式中，允许使用特殊的符合来指定其面前一个字符或一个组合单元重复的次数。</p>

<p>有如下几种指定重复次数的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++
</span><span class='line'> 限定符   |     描述的特征
</span><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++
</span><span class='line'>   *     |     重复0零次或更多次
</span><span class='line'>   +     |       重复1次或更多次
</span><span class='line'>   ?     |     重复0次或1次
</span><span class='line'>  {n}    |     重复n次
</span><span class='line'>  {n,}   |     重复n次或更多次
</span><span class='line'>  {n,m}  |     重复n到m次
</span><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></code></pre></td></tr></table></div></figure>


<h3>指定字符集</h3>

<p>如果我们事先知道在查找文本规则的特定位置的字符是在某个具体范围内，如某个位置上出现的字符只能是a,b,c,1,2,3中的一个时，正则表达式允许我们指定出这个字符集。</p>

<p>方法也很简单，就是将可能出现的字符放在方括号之中，如[abc123]即可。</p>

<p>对于连续的数字和字母，也可以用更简单的方法，如[0-9]表示出现的字符在数字0至9中的一个，类似的有[a-z]，[A-Z]。</p>

<p>还可以将上面的组合起来，如[0-9a-zA-Z]。</p>

<p>正则表达式中的那些有特殊意义的符合也可以不用转义直接放在其中，如[.?+]可匹配., ?, +。</p>

<h3>组合字符</h3>

<p>我们已经知道，要重复单个字符，可直接在这个字符后加上指定重复次数的限定符即可。</p>

<p>如果我们要指定一组连续的字符的重复次数，该如何做呢？</p>

<p>方法是先将这组连续的字符放到圆括号()中，然后在后面加上指定重复次数的限定符就可以了。</p>

<p>如(abc){2}，就描述了重复2次abc, 即abcabc。</p>

<p>更复杂的一个例子：(?0\d{2}[) -]?\d{8}</p>

<p>这个正则表达式可以这样来分析：</p>

<p>首先是一个转义字符(, 它能出现0次或1次(?), 然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。</p>

<h3>匹配多个正则表达式中的一个</h3>

<p>有时候一个正则表达式可能匹配出比我们预想要多的文本，如用于匹配电话号码的正则表达式(?0\d{2}[)-]?\d{8}，不仅可匹配(010)88886666、022-22334455、02912345678等正常的号码，还会匹配出010)12345678或(022-87654321等这样的&#8221;不正确&#8221;的格式。</p>

<p>要解决这个问题，我们可以明确指定出每一种电话号码的匹配规则，各个匹配规则之间用&#8217;|&#8217;来分隔，这样只有符合指定规则中的一种时才会被匹配，这有点类似于C/C++中的&#8217;或&#8217;运算。</p>

<p>例如，0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0512-6733445)。</p>

<h3>取反</h3>

<p>如果我们事先知道要查找的文本中肯定没有哪些字符，或者是要匹配除了某某字符之外的任意字符这种情况时，我们可以用类似C/C++中的&#8217;取反&#8217;运算来实现。</p>

<p>正则表达式允许的&#8217;取反&#8217;：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++
</span><span class='line'>元字符    |     描述的特征
</span><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++
</span><span class='line'>  \W     |     匹配任意不是字母，数字，下划线，汉字的字符
</span><span class='line'>  \S     |     匹配任意不是空白符的字符
</span><span class='line'>  \D     |     匹配任意非数字的字符
</span><span class='line'>  \B     |     匹配不是单词开头或结束的位置
</span><span class='line'> [^x]    |     匹配除了x以外的任意字符
</span><span class='line'> [^abc]  |     匹配除了abc这几个字母以外的任意字符
</span><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></code></pre></td></tr></table></div></figure>


<p>一些例子：</p>

<p>\S+        匹配不包含空白符的字符串</p>

<p>&lt;a[<sup>>]+></sup>   匹配用尖括号括起来的以a开头的字符串</p>

<h3>两种匹配模式：贪婪和懒惰</h3>

<p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。</p>

<p>例如，&#8221;a.*b&#8221; 它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。</p>

<p>如果我们希望匹配尽可能少的字符，只需在之前的限定符后加个问号&#8217;?&#8217;，这样将会以懒惰模式进行匹配。</p>

<p>例如，a.*?b 匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++
</span><span class='line'> 限定符   |     描述的特征
</span><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++
</span><span class='line'>   \*?   |     重复任意次，但尽可能少重复
</span><span class='line'>   +?    |       重复1次或更多次，但尽可能少重复
</span><span class='line'>   ??    |     重复0次或1次，但尽可能少重复
</span><span class='line'>  {n,}?  |     重复n次以上，但尽可能少重复
</span><span class='line'>  {n,m}? |     重复n到m次，但尽可能少重复
</span><span class='line'>++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></code></pre></td></tr></table></div></figure>


<hr />

<p>这些语法应该是正则表达式的最基础部分，还有一些高级的特性文中并没有涉及。</p>

<p>如果能够掌握并熟练使用上述的这些正则表达式的基本语法的话，我相信对于大多数的情况，正则表达式能够帮助我们快速的从复杂的文本中匹配出我们需要的内容。</p>

<p>从现在开始，慢慢感受正则表达式的强大吧!</p>

<p>(完)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress主题改造]]></title>
    <link href="http://shanewfx.github.com/blog/2012/08/13/improve-blog-theme/"/>
    <updated>2012-08-13T21:38:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/08/13/improve-blog-theme</id>
    <content type="html"><![CDATA[<p>Octopress是一个非常不错的博客系统，具有很好的扩展性，默认也提供了一个很好的博客主题。</p>

<p>随着越来越多的人开始使用Octopress搭建自己的个人博客，网络上出现了很多外观基本相同的博客。
虽然Octopress默认的主题设计的很简洁、美观，但为了打造一个属于自己的博客，还是希望能够做的更美观一些。
当然，借此机会自己也能够学习一点Web前端设计方面的知识。</p>

<!--more-->


<p>Octopress支持SASS语法，改造Octopress主题基本是通过修改“sass\custom“下以scss为后缀名的文件来完成，大多数的改造是在_styles.scss这个文件中来实现。</p>

<h2>1. 为博客添加背景图片</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>html {
</span><span class='line'>  background: #555555 url("/images/wood.jpg");
</span><span class='line'>  //background: #555555;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>body &gt; div { 
</span><span class='line'>  background-image: none; 
</span><span class='line'>//background: #F5F5D5
</span><span class='line'>} //侧边栏
</span><span class='line'>
</span><span class='line'>body &gt; div &gt; div { //文章内容
</span><span class='line'>  background-image: none; 
</span><span class='line'>  //background: #F5F5D5; 
</span><span class='line'>  //background: url("/images/textbg.jpg");
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>2. 改造博客的Header区域</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>html {
</span><span class='line'>  body &gt; header {
</span><span class='line'>    background: none;
</span><span class='line'>  padding: 1.6em 0 1em 0;
</span><span class='line'>  h1 {
</span><span class='line'>      @include text-shadow(0px 1px 0px #999, 0px 2px 0px #888, 0px 3px 0px #777, 0px 4px 0px #666, 0px 5px 0px #555, 0px 6px 0px #444, 0px 7px 0px #333, 0px 8px 7px #001135);
</span><span class='line'>    }
</span><span class='line'>    h2 {
</span><span class='line'>      margin-top: .5em;
</span><span class='line'>      display: none;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>3. 改造导航栏</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>body &gt; nav {
</span><span class='line'>  //background: url("/images/nav.jpg");
</span><span class='line'>  //background: #555555;
</span><span class='line'>  ul.main-navigation {
</span><span class='line'>    padding-left: 3px;
</span><span class='line'>  }
</span><span class='line'>  ul.subscription {
</span><span class='line'>    //display: none;
</span><span class='line'>  }
</span><span class='line'>  a {
</span><span class='line'>    &:hover {
</span><span class='line'>      color: hsl(209.01, 86.94%, 50.04%);
</span><span class='line'>      text-shadow:
</span><span class='line'>        hsl(209.01, 86.94%, 42.04%) 0px 0px 5px,
</span><span class='line'>        hsl(209.01, 86.94%, 42.04%) 0px 0px 7px,
</span><span class='line'>        hsl(209.01, 86.94%, 52.04%) 0px 0px 9px,
</span><span class='line'>        hsl(209.01, 86.94%, 52.04%) 0px 0px 11px,
</span><span class='line'>        hsl(0, 0%, 0%) 0 0 2px;
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>    i {
</span><span class='line'>      color: hsl(209.01, 86.94%, 50.04%);
</span><span class='line'>      text-shadow:
</span><span class='line'>        hsl(209.01, 86.94%, 42.04%) 0px 0px 5px,
</span><span class='line'>        hsl(209.01, 86.94%, 42.04%) 0px 0px 7px,
</span><span class='line'>        hsl(209.01, 86.94%, 52.04%) 0px 0px 9px,
</span><span class='line'>        hsl(209.01, 86.94%, 52.04%) 0px 0px 11px,
</span><span class='line'>        hsl(0, 0%, 0%) 0 0 2px;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>4. 倒圆角</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@media only screen and (min-width: 1040px) {
</span><span class='line'>  body &gt; nav {
</span><span class='line'>    @include border-top-radius(.4em);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  body &gt; footer {
</span><span class='line'>    @include border-bottom-radius(.4em);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>5. 给博客加上LOGO图片</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@media only screen and (min-width: 550px) {
</span><span class='line'>
</span><span class='line'>  body &gt; header h1{
</span><span class='line'>      background: url("/images/logo3.png") no-repeat 0 1px;
</span><span class='line'>      padding-left: 65px;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  body &gt; header h2 { padding-left: 65px; }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>6. 改造侧边栏</h2>

<p>在”source_includes\asides“下创建侧边栏相关模块的html文件，修改博客根目录下的_config.yml文件，主要是default_asides、blog_index_asides、post_asides这几项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default_asides: [custom/asides/about.html, custom/asides/weibo.html, asides/recent_posts.html, custom/asides/category_cloud.html, custom/asides/recent_comment.html, custom/asides/blog_link.html, custom/asides/douban.html, custom/asides/license.html]
</span><span class='line'>blog_index_asides: [custom/asides/about.html, custom/asides/weibo.html, asides/recent_posts.html, custom/asides/category_cloud.html, custom/asides/recent_comment.html, custom/asides/blog_link.html, custom/asides/douban.html, custom/asides/license.html]
</span><span class='line'>post_asides: [custom/asides/about.html, custom/asides/weibo.html, asides/recent_posts.html, custom/asides/category_cloud.html, custom/asides/recent_comment.html, custom/asides/blog_link.html, custom/asides/douban.html, custom/asides/license.html]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在custom/asides/about.html中添加About Me信息</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;section&gt;
</span><span class='line'>  &lt;h1&gt;About Me&lt;/h1&gt;
</span><span class='line'>  &lt;p&gt;&lt;img src="http://shanewfx.github.com/images/blogImgs/about.jpg"&gt;&lt;/p&gt;
</span><span class='line'>  &lt;p&gt;C++程序员，在Windows上搞音视频开发4年有余&lt;/p&gt;
</span><span class='line'>  &lt;p&gt;爱电子产品，爱Google, 爱折腾&lt;/p&gt; 
</span><span class='line'>  &lt;p&gt;喜欢开源的东西, 喜欢读书和思考, 喜欢做一些geek的事情/东西&lt;/p&gt;
</span><span class='line'>  &lt;p&gt;&lt;img src="http://shanewfx.github.com/images/myemail.png"  alt="shanewfx@gmail.com" /&gt;&lt;/p&gt;
</span><span class='line'>&lt;/section&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在custom/asides/weibo.html中添加新浪微博模块</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;section&gt;
</span><span class='line'>  &lt;h1&gt;Sina围脖&lt;/h1&gt;
</span><span class='line'>  &lt;iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=300&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=1684299551&verifier=e30813de&dpc=1"&gt;&lt;/iframe&gt;
</span><span class='line'>&lt;/section&gt;</span></code></pre></td></tr></table></div></figure>


<p>其中，iframe中的代码是来自新浪微博中”账号->我的工具->微博秀“，可以做一些简单的设置，并自动产生出嵌入代码。</p>

<ul>
<li>在custom/asides/douban.html中添加豆瓣读书列表</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>&lt;section&gt;
</span><span class='line'>&lt;h1&gt;My Douban&lt;/h1&gt;
</span><span class='line'>&lt;div&gt;
</span><span class='line'>&lt;script type="text/javascript" src="http://www.douban.com/service/badge/shanewfx/?show=wishlist&amp;n=9&amp;columns=3&amp;hidelogo=yes&amp;cat=movie|book" &gt;&lt;/script&gt;
</span><span class='line'>&lt;/div&gt;
</span><span class='line'>&lt;/section&gt;
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>其中，div中的代码来自<a href="http://www.douban.com/service/badgemakerjs">豆瓣</a>。
同时，要在_config.yml中添加douban_user: XXX (XXX为你的豆瓣用户名)。</p>

<ul>
<li>在custom/asides/blog_link.html中添加友情链接</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;section&gt;
</span><span class='line'>  &lt;h1&gt;大牛博客&lt;/h1&gt;
</span><span class='line'>  &lt;ul&gt;
</span><span class='line'>    &lt;li&gt;
</span><span class='line'>      &lt;a href="http://coolshell.cn/"&gt;酷壳CoolShell&lt;/a&gt;
</span><span class='line'>    &lt;/li&gt;
</span><span class='line'>    &lt;li&gt;
</span><span class='line'>      &lt;a href="http://mindhacks.cn/"&gt;刘未鹏MIND HACKS&lt;/a&gt;
</span><span class='line'>    &lt;/li&gt;
</span><span class='line'>    &lt;li&gt;
</span><span class='line'>      &lt;a href="http://blog.codingnow.com/"&gt;云风&lt;/a&gt;
</span><span class='line'>    &lt;/li&gt;
</span><span class='line'>    &lt;li&gt;
</span><span class='line'>      &lt;a href="http://www.cnblogs.com/Solstice/"&gt;陈硕&lt;/a&gt;
</span><span class='line'>    &lt;/li&gt;
</span><span class='line'>  &lt;/ul&gt;
</span><span class='line'>&lt;/section&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在custom/asides/recent_comment.html中添加Disqus评论</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;section&gt;
</span><span class='line'>  &lt;h1&gt;最新评论&lt;/h1&gt;
</span><span class='line'>  &lt;script type="text/javascript" src="http://shanewfx.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=200"&gt;&lt;/script&gt;
</span><span class='line'>&lt;/section&gt;</span></code></pre></td></tr></table></div></figure>


<p>其中，script中的代码由Disqus产生。
同时，需要修改_config.yml中Disqus的相关参数:
disqus_short_name: XXX (XXX为你的Disqus用户名)
disqus_show_comment_count: true</p>

<p>增加文章的评论需要将该文章对应的markdown文件开始部分中的comments设置为true（冒号后需有一个空格）。</p>

<h2>7. 增加一键分享</h2>

<p>我目前使用的是<a href="http://www.bshare.cn/">bshare</a>。</p>

<p>在_config.yml中增加bshare: true。
在“source_includes\post”下的sharing.html中增加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>    &lt;a class="bshareDiv" href="http://www.bshare.cn/share"&gt;Sharing&lt;/a&gt;&lt;script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#uuid=25fcdf85-62f9-400e-b053-627f102edf5a&amp;style=999&amp;img=http%3A%2F%2Fstatic.bshare.cn%2Fimages%2Fbuttons%2Fbox-shareTo-zh.gif&amp;w=147&amp;h=21"&gt;&lt;/script&gt;
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>上述的代码由bshare产生，可以自己选择所需的外观。
这样，在每一篇文章的最下方会出现一个分享的小工具。</p>

<h2>8. 添加标签云</h2>

<p>这部分需要第三方的plugin支持，目前我还没有解决中文标签在上传到github上连接出错的问题，在本地是OK的。
具体可参看<a href="http://tinyxd.me/blog/2012/06/25/octopress-add-tag-cloud/">这篇文章</a>。</p>

<p>（完）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[善用佳软 Notepad++]]></title>
    <link href="http://shanewfx.github.com/blog/2012/08/05/notepad-plus-plus/"/>
    <updated>2012-08-05T11:40:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/08/05/notepad-plus-plus</id>
    <content type="html"><![CDATA[<p>软件开发过程中少不了要通过查看Log文件来定位Bug，这当然需要有一个好用的文本编辑软件来配合。</p>

<p>目前为止，我使用过的文本编辑软件主要有：UltraEdit、<a href="http://www.vim.org/">VIM</a>、<a href="http://notepad-plus-plus.org/">Notepad++</a>。</p>

<p>虽然UltaEdit功能强大，但可惜是收费软件，而且许多功能平时也用不上，在如今优秀开源软件蓬勃发展的今天完全是可以找到一款替代软件。</p>

<!--more-->


<p>在查看Log文件过程中，UltraEdit的搜索功能是比较好用的，所以当然也希望替代的软件能够也拥有强大的搜索功能。</p>

<p>被誉为程序员编辑器的VIM，功能非常强大，开源软件，而且插件也很丰富，完全可以改造为一款IDE，但VIM的上手比较难，需要记住很多命令，且不同的编辑模式也是常人难以习惯的原因之一。
现在常被用来查看一些开源项目中文件。</p>

<p>Notepad++是最近才开始使用，在Windows下使用代替系统的Notepad是非常不错的，支持多文件同时打开，打开大文件的速度比较快，支持多种语法高亮，搜索功能也比较好用，支持插件扩展，其中HEX-Editor用来以16进制查看文件也是可以和UltraEdit相媲美的。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/7755743596/" title="Flickr 上 shanewfx 的 notepad"><img src="http://farm9.staticflickr.com/8422/7755743596_063f907f38.jpg" width="500" height="344" alt="notepad"></a></p>

<p>使用下来，Notepad++还是比较顺手的，也将会是我今后的常用软件之一。</p>

<p>(完)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[迁移VSS版本库到Git]]></title>
    <link href="http://shanewfx.github.com/blog/2012/05/09/migrate-from-vss-to-git/"/>
    <updated>2012-05-09T16:10:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/05/09/migrate-from-vss-to-git</id>
    <content type="html"><![CDATA[<p>公司最近有意将版本控制工具从VSS和CVS切换到Git上，由于之前的项目一直是使用VSS和CVS进行版本管理，这次迁移免不了要涉及VSS和CVS版本库向Git进行转换的工作。</p>

<p>带着这个目的，我先尝试着找到VSS到Git迁移的可行方案，因为我之前的项目一直也是用VSS进行版本管理，相对于从没有使用过的CVS而言，应该更容易上手一些。至于CVS如何迁移到Git会在后面进行研究。</p>

<!--more-->


<p>之前在学习使用GitStack搭建Git服务器时，在其官方网站上看到一篇讲如何<a href="http://gitstack.com/migrate-from-svn-to-git/">迁移SVN版本库到Git</a>的文章，文中有提到git svn命令，可见Git内部已经有了对SVN版本库进行操作的支持，继而顺着这个思路，试着去找找有没有支持对VSS和CVS的操作，结果发现Git没有对VSS的操作支持，对于CVS倒是有git cvsimport，但在Git Bash中却不认识该命令，运行<code>git help vcsimport</code>也没有相关的文档，而使用<code>git help vcs-migration</code>倒是有文档，其中也提到了git cvsimport，难道是我是在Windows上使用的Git（安装的是msysGit 1.7.10），而在Windows上还不支持该命令吗？不知道在Linux上的情况是怎么样的？</p>

<p>这个问题暂时先搁置，先研究一下如何将原有的VSS版本库迁移到Git上。</p>

<p>既然Git没有对VSS的支持，那么VSS转Git应该是需要第三方的工具来帮助实现这个转换工作（该工具要读取并分析VSS仓库的数据，然后按照Git版本库的内部结构来存放之前VSS版本库中的数据），按照这个思路，在Google上搜索了一下，果然发现有一个这样的工具，那就是<a href="http://code.google.com/p/vss2git/">vss2git</a>，而且是个开源的项目，很对我的胃口。</p>

<p>下载下来并试用了一下，结果成功将之前的一个用VSS管理的项目转换为Git仓库，并且<strong>之前VSS的历史信息也被保留下来</strong>，基本是满足了要求。</p>

<h3>VSS版本库到Git的迁移</h3>

<p>打开VSS2Git，其界面就是一个对话框，在其中作一些必要的设置，主要是设置VSS版本库所在的路径、要转换VSS版本库中哪一个项目（也可以是整个VSS版本库中全部的项目）、转换结果的存放位置、转换Log存放的位置、转换过程中创建Git提交对象时所需的email的domain等，设置好这些之后，点击Go按键即可开始VSS到Git仓库的转换。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/7163442740/" title="Flickr 上 shanewfx 的 VSS2Git"><img src="http://farm8.staticflickr.com/7088/7163442740_845fe43252.jpg" width="500" height="340" alt="VSS2Git"></a></p>

<p>转换所需的时间长短取决于VSS仓库的大小，如果VSS仓库中项目众多，且开发的时间都比较久的话，那么完成整个仓库的转换应该需要的时间会比较长，但如果只是转换其中一个项目到Git，那么时候会比较短。</p>

<p>转换后，通过<code>git log</code>可以看到之前VSS仓库中的历史信息，而且这些历史信息在Git仓库中仍然是按照提交时间的先后来排列的。</p>

<p>在转换过程中，打开存放Git仓库的目录，你会发现工作目录随着时间会在变化，这是因为VSS2Git在转换时会先分析并收集VSS仓库中的各种信息，然后再从VSS仓库中记录的最早的时间点开始Replay（演绎）整个VSS仓库数据形成的过程。</p>

<p>在演绎过程中，应该是先从VSS中取出最初的版本（Git仓库最初为一个空仓库），并将其版本中的文件作为Git工作目录的文件，然后按照Git先对工作目录进行文件快照再提交到Git仓库的做法，按照时间顺序逐个版本进行提交（提交时会取出VSS中对应版本的历史信息），最终将VSS版本库转换为Git仓库。</p>

<p>上述的演绎过程是我自己初步推断的大概过程，实际是否这么实现，请参考VSS2Git的源代码（用C#实现的）。
另外，VSS仓库内部的数据到底是如何组织的我也没有研究过。</p>

<p><strong>要注意的几点：</strong></p>

<ul>
<li><p>如果是要将整个VSS仓库中的所有项目都迁移到Git中，那么在VSS2Git界面的Project一项中填上<code>$</code></p></li>
<li><p>如果只是要将VSS仓库中的某一个项目迁移到Git上，则在Project一项中应填上<code>$/Project1</code> (其中Project1为假设的项目名)，甚至可以仅转换子项目，这样<code>$/Project1/32Bit</code></p></li>
<li><p>VSS2Git一次要么完成VSS仓库的整体转换，要么只能转换VSS仓库中其中一个项目，这样要实现多个项目的转换就要多次执行VSS2Git</p></li>
<li><p>VSS2Git的每一次转换会产生一个Git仓库，如果是VSS仓库一次整体转换，则生成的Git仓库中将包含VSS仓库中所有的项目，这样带来的问题是，由于Git仓库中包含了所有的项目，这样以后不同项目的开发人员无法从Git仓库中只checkout出自己负责的那个项目文件，而是要checkout出所有项目的文件，这样对于公司的代码安全是非常不利的，那么，这样就不应该一次将VSS仓库整体转换，而是应该以项目为单位进行逐个转换，这样，对于不同的项目，对其Git仓库就可以为不同的开发人员设置不同的操作权限</p></li>
<li><p>VSS2Git在生成Git提交信息所需的email时，只是根据从VSS中提取出的User名加上在界面Email domain中填写的内容组合而成，实际生成的email地址未必是有效的（不一定能用来发送email）</p></li>
</ul>


<p>更多的注意事项可至<a href="http://code.google.com/p/vss2git/">VSS2Git的主页</a>查看。</p>

<h3>导入现有的Git仓库到GitStack服务器上</h3>

<p>通过VSS2Git，我们可以将VSS仓库中的项目逐一转换为该项目的Git仓库，这时我们可以将其放置到Git服务器上了，以便后续的开发和维护。</p>

<p>这里，我们假设使用GitStack搭建了Git服务器（如何搭建见<a href="http://shanewfx.github.com/blog/2012/05/03/git-server-based-on-gitstack/">上篇</a>），现在的问题就相当于如何将一个现有的Git仓库导入到GitStack搭建的服务器上。因为正常的流程是在GitStack上先创建裸仓库，然后再向其中提交，如果这样做的话，我们之前的VSS中的历史信息恐怕就要丢失了，而这是我们不希望的结果。</p>

<p>不过幸运的是，GitStack支持导入一个现有的Git仓库到其中，其步骤也很简单，就是先将现有的Git仓库拷贝至C:\GitStack\repositories目录下面，然后登陆到GitStack上，在Repositories列表中会发现我们的Git仓库已经在其中，但Action栏则出现了一个绿色的安装，而非添加用户、查看仓库的那些按钮，这时我们只有点击这个绿色按钮就完成了该Git仓库的导入，之后我们会发现绿色的按钮被正常的添加用户、查看仓库的那些按钮替换掉，这时我们就可以为该Git仓库添加用户并设置访问权限了。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/7163501304/" title="Flickr 上 shanewfx 的 gitstack"><img src="http://farm6.staticflickr.com/5160/7163501304_4d08fab433.jpg" width="500" height="210" alt="gitstack"></a></p>

<p>具体的过程，在GitStack的文档中有详细的阐述，请见<a href="http://gitstack.com/import-an-existing-repository/">Import an existing repository</a>，这里不再赘述。</p>

<p>至此，如何将VSS仓库迁移到Git，并将生成的Git仓库导入到GitStack搭建的服务器上的大概过程就结束了。</p>

<p>（全文完）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于GitStack搭建Git中心服务器]]></title>
    <link href="http://shanewfx.github.com/blog/2012/05/03/git-server-based-on-gitstack/"/>
    <updated>2012-05-03T20:10:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/05/03/git-server-based-on-gitstack</id>
    <content type="html"><![CDATA[<p>通过前一段时间对Git的学习，基本掌握了Git常用命令的使用方法，并进行了总结，有兴趣的可以看看<a href="http://shanewfx.github.com/blog/2012/04/28/git-command-note/">Git常用命令的使用情景</a>和<a href="http://shanewfx.github.com/blog/2012/04/21/learn-git-command/">Git学习笔记</a>。</p>

<p>在<a href="http://shanewfx.github.com/blog/2012/04/28/git-command-note/">Git常用命令的使用情景</a>中提到过多人协作的项目往往是需要一个中心服务器来同步多人之间的工作成果，另外，最终的工作成果通常也是中心服务器上的代码为准（为了项目管理的需要），因此，备份时往往需要对中心服务器上的仓库进行刻盘。</p>

<p>中心服务器上创建的项目仓库一般为裸仓库（没有工作目录），且需要为项目开发人员设置访问和操作中心服务器上仓库的权限（访问、读、写）。</p>

<p>本文将介绍如何使用开源软件<a href="http://gitstack.com/">GitStack</a>在Windows上搭建Git中心服务器。</p>

<!--more-->


<p>为了学习如何在Windows上搭建Git服务器，用Google搜索了一下，发现多数的方案是采用CopSSH + msysgit + PuTTY的方式来实现，这种方案使用<a href="http://zh.wikipedia.org/wiki/SSH">SSH</a>协议（采用公钥和私钥进行身份验证，用<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">PuTTY</a>可以产生公钥和私钥，关于公钥和私钥可参考<a href="http://www.360doc.com/content/12/0502/18/1016783_208170505.shtml">这篇</a>入门介绍）与Git服务器通信，在安全性上应该来说是比较高的，但缺点就是搭建过程比较麻烦，且要清楚一些概念才知道自己在做什么，因此对新手来说有一定的难度。</p>

<p>另外，让我暂时没采用这种的方案的原因是CopSSH已经不再免费了（找到一个免费的版本<a href="http://sourceforge.net/projects/sereds/files/Copssh/3.0.3/">Copssh 3.0.3</a>，需要将<a href="http://sea.tomsk.ru/pub/soft/git/Copssh_3.0.3_Installer/">icwbase-2.0.3-patch-100.exe</a>这个补丁拷贝到Copssh的安装目录下运行来修复回退键和左右方向键不能正常的问题），对于喜欢开源软件的我来说，还是希望能够找到其他的开源软件来代替。</p>

<p>关于这种方案的几篇文章：</p>

<ul>
<li><p><a href="http://www.codeproject.com/Articles/296398/Step-by-Step-Setup-Git-Server-on-Windows-with-CopS">Step by Step Setup Git Server on Windows with CopSSH + msysGit and Integrate Git with Visual Studio</a></p></li>
<li><p><a href="http://www.timdavis.com.au/git/setting-up-a-msysgit-server-with-copssh-on-windows/">Setting up a Msysgit Server with copSSH on Windows</a></p></li>
<li><p><a href="http://www.cnblogs.com/Yinner/archive/2011/05/01/2034147.html">如何在WINDOWS XP下使用copSSH配置GIT服务器 + TortiseGIT客户端</a></p></li>
</ul>


<p>另外，还有一种采用Gitolite来搭建的方案，可参考<a href="http://www.ossxp.com/doc/git/gitolite.html">Gitolite构建Git服务器</a>，讲的很详细。</p>

<p>无意之中，通过google发现了<a href="http://gitstack.com/">GitStack</a>，查看了官方文档，感觉不需要做什么特殊的设置就可以在Windows上搭建Git服务器，并且对用户权限的设置也很简单，故决定下载下来试用一下，测试下来果然很方便，且在Client端也成功进行了clone和push等操作（虽然中间遇到一个问题，后面会提到）。</p>

<p>为了以后有个参考，特在此记录下用GitStack搭建Git服务器的主要过程。</p>

<p>工具列表：</p>

<ul>
<li>服务器端：<a href="http://gitstack.com/download/">GitStack 1.4.1</a>，GitStack中已经集成了Git，可以不用再独立安装msysgit</li>
<li>客户端：<a href="http://code.google.com/p/msysgit/downloads/list">msysgit 1.7.10</a></li>
</ul>


<h3>下载并安装GitStack</h3>

<p>到其<a href="http://gitstack.com/">官方网站</a>上下载最新版的<a href="http://gitstack.com/download/">GitStack 1.4.1</a>。</p>

<p>安装文件有100M，要注意的是，目前GitStack只支持下面几个系统（不支持Windows XP）：</p>

<ul>
<li>Windows Server 2008</li>
<li>Windows Server 2008 R2</li>
<li>Windows Vista</li>
<li>Windows 7</li>
</ul>


<p>另外，GitStack是一个新的开源软件（可以看看<a href="http://gitstack.com/category/releases/">release的历史</a>），目前有些功能可能还不是很完善，文档也不是很全面，好在GitStack并不复杂。</p>

<p>安装和普通的Windows软件一样，双击安装包自动进行安装，要注意的是最好其安装路径中不要包括空格，所以不建议安装到C:\Program Files下，默认是安装到C:\GitStack下。</p>

<p>安装好GitStack后，下面主要就是配置GitStack和仓库管理。</p>

<p>提醒一下，只需要在服务器上安装GitStack即可，其他的客户机上是不要安装的。安装好GitStack后，可以在任意机器上通过浏览器登录到Git服务器上（当然实际上只有仓库的管理员才有权限登录）。</p>

<h3>GitStack的配置</h3>

<p>在服务器上，可以通过开始菜单找到GitStack打开，也可以直接打开浏览器，在地址栏里输入http://localhost/gitstack/打开登录界面。</p>

<p>另外，也可以通过server机的IP地址来登录，如server的IP地址为：192.168.0.105，则可以直接在浏览器的地址栏中输入http://192.168.0.105/gitstack/打开登录界面(注意在客户机上只能使用这种方式来打开登录界面，通过ipconfig可以查看本机的IP地址)。</p>

<p>初始状态下，默认的登录账户为admin，登录密码也为admin。管理员登录后可在Settings->General中修改admin的登录密码。</p>

<p>勾选Enable web based repository browsing选项开启在浏览器中直接查看Git仓库的内容。</p>

<p>另外还有两个Repositories和Users &amp; Groups两个界面，其中在Repositories中可以在服务器上创建项目的裸仓库，直接输入仓库名（如输入ProjectRepos），然后点击Create按钮即可（会在服务器C:\GitStack\repositories下创建一个ProjectRepos.git裸仓库），创建好的仓库也会在Repositories中显示出来，并显示出该仓库的clone的地址git clone http://localhost/ProjectRepos.git，之后就可以在Action下通过浏览器查看仓库、添加用户/Group并设置用户/Group权限等。</p>

<p>在Users &amp; Groups中，Users下是用来创建用户或修改用户密码等，每个用户对应一个Username和其Password，已有的用户会在上面的列表中显示出来；Groups下用于创建组，可以在每个Group下添加或移除用户，已有的Group也会在列表中显示出来。</p>

<p><a href="http://www.flickr.com/photos/shanewfx/7163525050/" title="Flickr 上 shanewfx 的 gitstack_1.5"><img src="http://farm9.staticflickr.com/8164/7163525050_4e0a696de9.jpg" width="500" height="370" alt="gitstack_1.5"></a></p>

<h3>牛刀小试</h3>

<p>上述已经在服务器上创建了一个ProjectRepos.git裸仓库，现在我们在服务器上来克隆该仓库。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd d:
</span><span class='line'>mkdir project
</span><span class='line'>cd project
</span><span class='line'>git clone http://192.168.0.105/ProjectRepos LocalRepos 或 git clone http://localhost/ProjectRepos LocalRepos 或 git clone http://localhost:80/ProjectRepos LocalRepos</span></code></pre></td></tr></table></div></figure>


<p>默认的是80端口，可以修改为其他端口。
这里，会提示输入用户名和密码，注意输入的用户名和密码不会被显示出来。</p>

<p>cd LocalRepos
进入了工作目录，我们可以添加文件到工作区，并提交到本地仓库中。</p>

<p>然后，将本地修改推送到服务器的仓库里：git push origin master，这里会提示输入用户名和密码，注意输入的用户名和密码不会被显示出来。
通过git remote -v，我们可以查看origin对应的服务器上的仓库地址。</p>

<p>这时打开GitStack，可以看到服务器上仓库有了提交的内容。</p>

<h3>在客户机上克隆服务器的仓库到本地</h3>

<p>先在客户机上安装msysgit 1.7.10。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd d:
</span><span class='line'>mkdir project
</span><span class='line'>cd project
</span><span class='line'>git clone http://192.168.0.105/ProjectRepos LocalRepos</span></code></pre></td></tr></table></div></figure>


<p>这里，会提示输入用户名和密码，注意输入的用户名和密码不会被显示出来。</p>

<p>cd LocalRepos
进入了工作目录，我们可以添加文件到工作区，并提交到本地仓库中。</p>

<p>然后，将本地修改推送到服务器的仓库里：git push origin master，这里会提示输入用户名和密码，注意输入的用户名和密码不会被显示出来。
通过git remote -v，我们可以查看origin对应的服务器上的仓库地址。</p>

<p>这时打开GitStack，可以看到服务器上仓库有了提交的内容。</p>

<p>在客户机上也可以打开GitStack，直接在浏览器的地址栏中输入http://192.168.0.105/gitstack/打开登录界面，当然这需要知道管理员密码。</p>

<p>（这里要注意的是，要保证在客户机上能够成功打开GitStack或者从服务器上克隆仓库，必须将服务器的防火墙关闭，否则在客户机上的这些操作就会失败。这个问题一直困扰了我好几个小时。）</p>

<p>可见，服务器和客户机在操作上已经没有什么区别了，这正是Git作为分布式版本控制系统的体现。</p>

<p>（全文完）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[库的可扩展性与二进制兼容性]]></title>
    <link href="http://shanewfx.github.com/blog/2012/05/02/binary-compatibility/"/>
    <updated>2012-05-02T15:44:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/05/02/binary-compatibility</id>
    <content type="html"><![CDATA[<p>读了<a href="http://www.cnblogs.com/Solstice/">陈硕</a>写的关于库的<strong>二进制兼容(binary compatibility)</strong>方面的文章，深感此内容的重要性，值得在以后的设计中多加考虑和实践。</p>

<p>在此，记录一下读后感，总结一下在设计库接口时应该考虑的事项，以备后用。</p>

<p>参考的文章如下:</p>

<ul>
<li><p><a href="http://www.cnblogs.com/Solstice/archive/2011/03/09/1978024.html">二进制兼容性</a></p></li>
<li><p><a href="http://www.cnblogs.com/Solstice/archive/2011/03/13/1982563.html">避免使用虚函数作为库的接口</a></p></li>
</ul>


<p>另外，作者将其博文整理出一份<a href="http://cloud.github.com/downloads/chenshuo/documents/CppPractice.pdf">C++工程实践经验谈</a>，很值得一读。</p>

<!--more-->


<p>以往开发directshow filter时，其接口通常都是采用由纯虚函数组成接口类的方式来实现，其主要原因应该是directshow是以COM为基础而设计出来的框架。</p>

<p>对于一个filter，在发布时，通常要提供一个header file和一个.ax结尾的dll文件，header file告诉AP该filter提供了哪些接口和相关数据结构。</p>

<p>这时，如果有一个新功能需求，需要在原filter的基础上增加，并且新版本的filter要能够直接在AP中直接替换老版本，而不影响AP原有功能（新功能会在下一版AP中被添加），这时，我们该怎么办？</p>

<p>参考陈硕文章中的做法，应该可以这样实现: 新的功能在新的接口中定义，并且新的接口要继承于旧的接口。</p>

<p>大概的实现应该是这样的（略去了其他细节）:</p>

<p><strong>老版本:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class interface1 {
</span><span class='line'>public:
</span><span class='line'>     virtual int func1() = 0;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>class filter : public interface1 {
</span><span class='line'>     virtual int func1();
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p><strong>新版本:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class interface2 : public interface1 {
</span><span class='line'>public:
</span><span class='line'>     virtual int func2() = 0;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>class filter : public interface2 {
</span><span class='line'>     virtual int func1();
</span><span class='line'>     virtual int func2();
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>这样做基本满足了要求（二进制兼容的），但这种做法引进了新的接口，而且为了向下兼容，还需要继承老的接口，如果日后新的需求不断出现，则会有更多的接口被引入，长期下去容易引起混乱，对于后续维护的人而言，也可能会造成困惑，因此，这种带版本的接口似乎不是一个很完美的方案。</p>

<p>对于那些老的采用虚函数作为接口的项目，如果后来又新需要，则上述的方法是可取的，因为，你不太可能去修改之前经过测试的稳定代码。</p>

<p>如果是新的项目，可以在设计的时候多考虑一些库的可扩展性和二进制兼容性问题。</p>

<p>二进制兼容性问题是在库扩展新功能或修复bug后更新版本时需要考虑的。</p>

<p>为什么要考虑这样的问题？</p>

<p>因为使用库的项目有很多个，不太能因为某个库的更新而要求所有使用该库的项目全部重新编译，通常，只是要告之用新版本替换相应的老版本库即可，而要达到这样的目的，就需要该库做到接口的二进制兼容。</p>

<p>典型的例子就是那些支持热插拔的plug-in系统，更新插件不需要其宿主也跟着要改变。</p>

<p><strong>下面是不影响二进制兼容的安全做法:</strong></p>

<ul>
<li><p>增加新的class</p></li>
<li><p>增加non-virtual成员函数或者static成员函数</p></li>
<li><p>修改数据成员名称（二进制兼容，但会引起源代码级的不兼容，也容易产生问题）</p></li>
<li><p>增加新的全局函数（自由函数）</p></li>
</ul>


<p><strong>下面是一定影响二进制兼容的不安全做法（容易造成crash问题）:</strong></p>

<ul>
<li><p>接口采用虚函数，并在接口中添加新的虚函数（影响了vtable[offset]），就算在尾部添加也是有问题的，因为不能保证该接口没有被继承</p></li>
<li><p>修改接口中使用的数据结构，如数据类型从short改为int（改变的内部布局）</p></li>
</ul>


<p>为了保证库的可扩展性和二进制兼容，在设计库的接口时，可考虑下面的做法：</p>

<p><strong>1. 用class的non-virtual成员函数作为接口，并且所有的操作放在一个内部class来代理实现</strong></p>

<p><strong>老版本:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Interface {
</span><span class='line'>public:
</span><span class='line'>    Interface() : pImpl(new Impl) {}
</span><span class='line'>    ~Interface() { delete pImpl; }
</span><span class='line'>    int func1() { return pImpl->func1(); }
</span><span class='line'>
</span><span class='line'>private:
</span><span class='line'>    class Impl;
</span><span class='line'>    Impl* pImpl;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p><strong>新版本:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Interface {
</span><span class='line'>public:
</span><span class='line'>    Interface() : pImpl(new Impl) {}
</span><span class='line'>    ~Interface() { delete pImpl; }
</span><span class='line'>    int func1() { return pImpl->func1(); }
</span><span class='line'>    int func2() { return pImpl->func2(); }
</span><span class='line'>
</span><span class='line'>private:
</span><span class='line'>    class Impl;
</span><span class='line'>    Impl* pImpl;
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p><strong>2. 使用全局函数作为接口（这种做法在C语言中是最为常见的），内部还是按C++的方式来实现</strong></p>

<p><strong>3. 不得以的情况下，可以使用虚函数做为接口</strong></p>

<p>(全文完)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一道智力题引发的思考]]></title>
    <link href="http://shanewfx.github.com/blog/2012/04/29/a-story/"/>
    <updated>2012-04-29T21:01:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/04/29/a-story</id>
    <content type="html"><![CDATA[<p>前一段时间在<a href="http://cooffee.net/">酷啡生活</a>的博客中看到这样的一道智力题:</p>

<p><strong>&#8220;荷塘里有一片荷叶，它每天会增长一倍。假使30天会长满整个荷塘，请问第28天，荷塘里有多少荷叶?&#8221;</strong></p>

<!--more-->


<p>答案要从后往前推，即有四分之一荷塘的荷叶。</p>

<p>这时，如果站在荷塘的对岸，也会发现荷叶是那样的少，似乎只有那么一点点，但是，第29天就会占满一半，第30天就会长满整个荷塘。</p>

<p>在荷叶长满荷塘的整个过程中，荷叶每天变化的速度都是一样的，可是前期花了漫长的28天。那时，我们看到荷叶只能占领一个小小的角落。</p>

<p>在积累知识、实现自己梦想的过程中，即使我们每天都在进步，然而，前面那漫长的&#8221;28天&#8221;因无法享受到结果，常常令人难以忍受, 大多数人在这28天以前就放弃。人们常常只对&#8221;第29天&#8221;的希望与&#8221;第30天&#8221;的结果感兴趣，但是不愿忍受漫长的成功过程。</p>

<p><em>(以上内容来自<a href="http://cooffee.net/?p=3258">酷啡生活</a>，作者hellen)</em></p>

<h2>可见，在通往成功的道路上，耐心和持之以恒是必备的&#8221;干粮&#8221;!</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git常用命令的使用情景]]></title>
    <link href="http://shanewfx.github.com/blog/2012/04/28/git-command-note/"/>
    <updated>2012-04-28T13:43:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/04/28/git-command-note</id>
    <content type="html"><![CDATA[<p>在<a href="http://shanewfx.github.com/blog/2012/04/21/learn-git-command/">上一篇</a>已经大概讲了一下Git中的常用命令，本文希望能够在此基础上再做些总结，以结束Git第一阶段的学习。</p>

<p>本文尽量指出在不同情景下如何选择合适的Git命令来达到自己的目的，当然，由于Git太过强大、灵活，有时同一问题可以有多种不同的解决方案，这里不太可能全部列出，只会选择一些自己测试可用的方法。</p>

<p>文中会稍微谈一些Git内部实现的细节，但不会太具体，同时这些内容大部分是基于自己在学习过程中的一些理解，所以也不能保证相关的解释一定是正确的。</p>

<p>如发现有误，请告之，在此谢过!</p>

<!--more-->


<h2>1. 工作的开始 &#8211;创建Git仓库</h2>

<p>Git仓库的创建通常有如下几种情况：</p>

<ul>
<li>在项目的开始阶段创建Git仓库，这时，项目刚开始，使用项目中的文件都没有被纳入Git仓库中</li>
</ul>


<p>进入项目的根目录，直接执行<code>git init</code>，这样就在根目录下创建了Git仓库，表现就是在根目录下多了一个隐藏的.git目录，它对应的就是git仓库。</p>

<ul>
<li><p>如果项目已经进行了一段时间或者是之前的项目想使用git进行版本管理，这时要创建Git仓库，也是直接到项目的根目录下，执行<code>git init</code>即可</p></li>
<li><p>如果项目是多人协作，通常需要一个中心服务器来协作多人之间的工作成果</p></li>
</ul>


<p>在中心服务器上通常是创建一个裸仓库（没有工作目录），方法是执行在项目根目录下执行<code>git init --bare</code>。</p>

<ul>
<li>如果项目已经使用了git，且已经放到了中心服务器上，这时，有新人要参加该项目，他要开始工作，就需要使用<code>git clone</code>从中心服务器上获得该项目的git仓库</li>
</ul>


<h2>2. 为当前工作区做文件快照</h2>

<p>我们在工作目录中进行工作，然后需要将工作区中文件的变化情况告诉git。git与其他的版本控制系统的区别在于如果工作区的文件改动过，则git会在提交前进行一次文件快照，记录当前工作目录下所有文件和文件夹的拓扑结构及内容。为了效率和节省空间，内容相同的文件在git仓库中只会有一个blob对象来保存其内容，对于变化的文件，git会在内部创建新的blob对象，而没有变化的文件则在快照中引用之前仓库中的blob对象，这样，从每一次的提交中我们就能够知道当时工作区中文件和目录的情况。而其他版本控制系统则是保存文件的差异。</p>

<p>在工作区，文件的状态一般有如下几种：</p>

<ul>
<li>未跟踪的文件：新增加的文件或之前没有提交到git仓库的文件且没有加到.gitignore文件中</li>
<li>已修改未暂存：已经纳入git仓库，在工作区被修改的文件，但还没有进行文件快照</li>
<li>已暂存等待提交： 已经纳入git仓库，在工作区被修改的文件，且已经进行文件快照</li>
<li>已删除：已经纳入git仓库，在工作区中被删除</li>
</ul>


<p>给工作区进行文件快照，使用<code>git add</code>命令，常见用法有：</p>

<ul>
<li><code>git add .</code> 工作区的文件变动全部被添加到git的index file中</li>
<li><code>git add -u</code> 将工作区中已经纳入git仓库的文件变动添加到index file中，但新增加的文件不会被添加</li>
<li><code>git add file</code> 手动一个一个地将指定的文件添加到index file中</li>
</ul>


<p>要查看当前文件快照的内容，可以使用<code>git  ls-files --stage</code>命令来实现，它会列出index file中文件的blob对象id和文件名。</p>

<h2>3. 将文件快照提交到git仓库中</h2>

<p>对工作目录进行文件快照后，其修改的文件并未真正纳入git仓库，需要使用git commit命令将其真正提交保存到git仓库中。</p>

<p>每一次提交，git都会要求输入相应的commit信息，这样也便于今后能够快速找到指定的版本。</p>

<p>如果已经对工作区进行了文件快照，则直接执行<code>git commit -m "commit information"</code>, 这里用单引号或双引号都可以，如果这时没有加上-m选项，那么git会自动打开编辑器，让你输入提交信息，复杂的提交信息可以这样使用。</p>

<p>如果并没有对工作区进行文件快照，且只希望将已经纳入git管理的文件的变更提交到仓库中，这时，可以直接执行<code>git commit -a -m 'commit information'</code>，实际上，这只是将git add 和git commit两条命令合并起来执行。</p>

<p>git会为每一次的提交产生一个commit对象，该commit对象指向了当前的文件快照（由tree对象和blob对象组成），并且还会指向其前一次的commit对象，以形成commit提交历史。</p>

<p>另外，git内部有一个HEAD始终会指向当前分支最新的一次commit对象，每一次提交，HEAD也会跟着移动。</p>

<h2>4. 查看工作区的文件状态</h2>

<p>要了解当前工作区中的文件有没有被修改或有没有增加或者删除文件，都可以通过<code>git status</code>来查看，同时还能够了解到修改的文件没有被放入到index file中或者没有被提交到git仓库中。如果当前工作区中文件的变化都已经被提交到仓库中，则此时的工作区就是处于一个clean的状态。</p>

<h2>5. 将对外Release版本和内部开发版本分开</h2>

<p>对于软件开发，常常会遇到要修正bug、增加新功能等需求，为了不影响正常Release出去的版本，我们往往会希望自己修改的部分最好与之前的版本分开，这时候，使用分支是个不错的选择。在git中，分支是非常强大的，并且实现的成本的也很低，这是其他版本控制系统无法比拟的。灵活使用git的分支，可以帮助我们实现比以往更好、更简单的开发管理。</p>

<p><code>git branch</code>可以列出当前git仓库中已经存在的分支名；知道分支名，我们可以使用<code>git checkout 分支名</code>将工作区切换到指定的分支，这样我们就可以在这个分支上进行开发或者修正bug等工作，同时，在该分支所作的改动不会影响到其他分支。</p>

<p>要创建新分支，可以实现<code>git branch 新分支名</code>来创建，但此时并不会自动切换到新创建的分支，需要继续使用<code>git checkout 分支名</code>来切换。</p>

<p>如果想在创建分支后自动切换到该分支的话，则可以使用<code>git checkout -b 新分支名</code>。</p>

<p>上述的分支创建都是默认基于当前所在分支来创建新的分支，因此，创建并切换到新分支后工作区的文件和之前是一样的。</p>

<p>如果想基于某个指定的版本来创建分支，则需要在创建时明确地指出希望是基于哪个起点来建立新分支，这个起点可以是某个分支的最新commit，某次commit或者指定的tag等，即<code>git checkout -b 新分支名 [分支的起点]</code>。</p>

<p>在切换分支时，如果当前所在分支的工作区有文件被改动，则必须将这些改动提交到仓库或者使用git stash将当前分支状态暂时保存起来，否则分支切换就会失败。</p>

<p>当开发分支的功能已经完成，则可以将最新成果合并到主分支或者release分支。</p>

<p>要合并开发分支，需要先将分支切换到主分支或release分支，然后执行<code>git merge 开发分支名</code>来完成。</p>

<p>如果开发分支的修改是在主分支增加内容，不修改之前的内容（可以增加新文件但没有删除文件、同一文件没有修改之前的内容）时，这时合并应该是成功的（新增的部分自动合并在一起）且自动提交到git仓库中。如果同一文件在同一行的同位置有变动，则这时合并就发生的冲突（git会指示出哪个文件有冲突），自动合并过程被中止，这时就需要我们手动打开有冲突的文件（有冲突的部分可以git会在文件中加上特殊的符号标示出来，具体可以使用<code>git help merge</code>查看相关文档），并自己决定如何两个分支的内容。冲突解决后，需要自己提交到仓库中。</p>

<p>如果冲突的内容比较多时，我们可以借<code>助git mergetool</code>打开配置的工具来协作解决冲突。</p>

<p>分支合并完成后，我们可以使用<code>git branch -d 分支名</code>删除不需要的分支，要使该命令执行成功，应保证要被删除的分支已经被其他分支合并，否则会失败。如果要强制删除，不管该分支有没有被合并，则应该使用<code>git branch -D 分支名</code>，这种情况通常是用于删除那些试验失败的分支。</p>

<p>要查看分支，除了在Bash中使用<code>git branch</code>来列出已存在的分支，还可以使用<code>gitk</code>命令打开图形界面比较直观的查看各分支的提交历史和分支间的相互关系。</p>

<h2>6. 误操作的撤销</h2>

<p>在git中，各种命令的执行会影响到工作区、暂存区、git仓库三者的状态。</p>

<p>如果发生了误操作，想撤销这个操作，并恢复到某个希望的状态时，这时就需要使用<code>git reset</code>命令了。</p>

<p>如果工作区中的一些文件被修改，并且已经暂存到index中（还未提交），这时发现有些文件的修改还未真正完成，想撤销之前的git add并在工作区中保留这些文件之前的修改内容时，我们<code>git reset --mixed HEAD</code>，这时index中内容和HEAD对应的index内容一致，但工作区还是我们修改后的状态，用<code>git status</code>会显示这些文件的状态时已修改未暂存，注意此时提交并没有被撤销。（注意，&#8211;mixed是缺省的选项，因此<code>git reset HEAD</code>和<code>git reset --mixed HEAD</code>是等同的）</p>

<p>对于上述情况，如果仅仅是要index中撤销某个文件，可以使用<code>git checkout -- file</code>来完成。</p>

<p>如果上述已经提交，想撤销最近一次的提交，则可以使用<code>git reset --mixed HEAD^</code>，这时commit和index都被恢复到HEAD之前的一次提交状态，但工作区没有改变。</p>

<p>如果仅是想撤销最近一次的提交，但想保留当前index和工作区的状态，则使用<code>git reset --soft HEAD^</code>，而git reset &#8211;soft HEAD执行后，commit、index、work tree的状态都没有改变，因此，没有实际意思。</p>

<p>如果想将commit、index、work tree的状态都恢复到前一个版本的状态，则可以使<code>git reset --hard HEAD^</code>，这时要注意的是之前的所有修改被被丢弃，因此，这条命令使用时要确保当前的修改已经被提交到仓库中或者确定要放弃这些修改。另外，从这里也可以看出，使用<code>git reset --hard 指定的版本ID</code>可以将指定的版本的code从仓库中取出来查看。</p>

<p>如果发现提交时，填写的提交信息有误，则可以使用<code>git commit --amend</code>来修改；另外，如果发现提交时，漏掉某些文件，并希望将这些文件也追加到上次的提交中，可以先使用<code>git add .</code>将这些文件先暂存起来，然后使用<code>git commit -amend</code>来完成提交。</p>

<h2>7. 查看提交历史</h2>

<p>在git中，每一个提交在git仓库中都会有相应的历史记录，这样就便于我们今后在需要的时候来查看，例如，我们想知道某个版本对应的commit对象ID，这样我们就可以恢复到这个版本来查看这个版本的状态。</p>

<p>通过git log可以查看所有分支所有的提交历史信息。这些信息中，主要包括commit对象id、提交人的信息和提交时间、提交时附加上的提交信息等。</p>

<p>在经过一段时候后，可能分支上已经有很多次提交，这样git仓库中保留的历史也很多，因此，在查看时，我们需要经过一些过滤来选出我们需要的内容。</p>

<p><code>git log -p</code>会显示出每次提交做了哪些改动，<code>git log -3</code>只列出最近三次的提交历史，<code>git log --pretty=format:"%H : %s"</code>只列出每次提交的ID和提交信息，
<code>git log --graph</code>会以图形化的方式显示各分支的提交历史，<code>git log commit1..commit4</code>列出commit1和commit4之间的提交历史(不包括commit1，但包括commit4)，<code>git log commit1...commit4</code>列出commit1和commit4之间的提交历史(不包括commit1和commit4)。</p>

<p>上述的选项可以组合起来使用，如<code>git log -5 --graph</code>就会以图形的方式显示最近5次的提交历史。</p>

<p>更多的git log的选项的使用方法请使用git help log来查看。</p>

<p>另外，用<code>git show</code>可以查看指定的某次提交历史，通过<code>git reflog</code>可以查看HEAD曾经指向的commit对象的ID。它们的详细用法请查看其帮助文档。</p>

<p>通过<code>git shortlog -s -n</code>会显示出总的提交次数。</p>

<h2>8. 通过commit对象来查看该版本的文件快照内容</h2>

<p>如果我们想看看指定版本的文件快照内容，则我们需要先知道该版本的commit对象的ID。</p>

<p>通过<code>git log</code>或<code>git reflog</code>来找出指定版本的commit对象的ID。</p>

<p>通过<code>git cat-file -t ID</code>来确认该对象的类型：commit（提交）、tree(目录)、blob（文件）、tag（标签）。</p>

<p>通过<code>git cat-file commit commit-ID</code>来查看commit对象的内容，主要包括：tree对象、前一个commit对象、提交人信息、提交附加信息等，其中，tree对象就是文件快照的根目录。</p>

<p>通过commit对象知道了文件快照根目录对应的tree对象，使用<code>git ls-tree tree-id</code>来查看tree对象的内容，主要包括：其他tree对象、blob对象。</p>

<p>知道了blob对象，我们就可以通过<code>git cat-file blob blob-id</code>来查看文件的内容。</p>

<p>note：git的这些内部对象都存储在.git/object目录下，其中，每个对象用其ID前2个字符作为存储该对象的文件夹名，并在该文件夹下使用其ID剩余的38个字符作为存储该对象的文件名，这个文件就是真正存储对象内容的地方，其中的内容时被压缩过的，需要使用上述的git命令来查看。如果执行过git gc，.git/object目录下的文件会被压缩存放到.git/object/pack和.git/object/info目录下。通过find可以列出.git目录下所有目录和文件，这样就可以清楚地知道当前仓库的目录结构。</p>

<p>要查看当前分支的index内容，使用<code>git ls-files --stage</code>，它列出了文件名及对应的blob对象的ID。</p>

<p><code>git ls-files</code>根据不同的选项可以查看到文件，如将工作目录中的某些文件误删除了，这时可以使用<code>git ls-files -d |xargs git checkout --</code>即可恢复这些被删除的文件。</p>

<h2>9. 给每个release版本打上标签(里程碑)</h2>

<p>通常情况下，每个release版本都会有一个版本号与之对应，在git中，我们可以将该版本号作为tag来代表某个正式的release版本。这样的方便之处在于，以后我们可以通过tag快速定位到指定的版本，而不需要通过在冗长的提交历史中慢慢查找。</p>

<p>通过<code>git tag</code>可以列出仓库中所有的tag，要为当前分支最近一次的提交（HEAD）创建新的tag，使用<code>git tag [-a] 标签名 -m "附加信息"</code>，这样以后就可以用该标签名来代替当前分支的这次提交commit对象的ID。</p>

<p>要删除某个tag，使用<code>git tag -d 标签名</code>即可。</p>

<p>note：在想远程仓库push时，tag并不会自动被push到远程仓库中，需要自己手动去push，如<code>git push origin v1.0.0.1</code>。</p>

<h2>10. 与中心服务器的交互</h2>

<p>如果我们本地机器上没有某个项目的仓库，但中心服务器上已经有项目的仓库，我们可以用<code>git clone 中心服务器上仓库地址 本地文件夹</code>来从中心服务器上克隆一份项目的仓库，并在工作目录中进行开发工作。</p>

<p>如果我们本地机器上已经有了项目的仓库，则要从服务器上抓取最新的内容，可以使用<code>git pull</code>或者<code>git fetch</code>来实现，区别是git pull会将服务器上抓回来的内容与本地分支进行合并，而git fetch则不会进行合并。</p>

<p>在我们本地完成工作，需要将最新的成果放到服务器上时，我们可以使用<code>git push</code>来实现。</p>

<p>上述的操作都需要事先知道服务器上项目仓库的地址，并使用<code>git remote add</code>保存在本地并起了个别名，这样以后就可以直接使用别名来代替服务器上项目仓库的地址。</p>

<ul>
<li>查看本地已经添加的远程仓库： git remote仅显示已添加的远程仓库名，git remote -v可以一并查看远程仓库的地址</li>
<li>在本添加远程仓库： git remote add 远程仓库名 远程仓库地址</li>
<li>删除本地添加的远程仓库： git remote rm 远程仓库名</li>
<li>重命名远程仓库名： git remote rename 原名 新名</li>
<li>克隆远程仓库到本地： git clone 远程仓库地址 [克隆到指定文件夹]</li>
<li>从远程仓库抓取最新数据到本地但不与本地分支进行合并： git fetch 远程仓库名</li>
<li>从远程仓库抓取最新数据并自动与本地分支进行合并： git pull 远程仓库名 本地要合并的分支名</li>
<li>将本地仓库推送到远程仓库中： git push 远程仓库名 本地分支名</li>
<li>查看远程仓库信息： git remote show 远程仓库名</li>
<li>将标签推送到远程仓库： git push 远程仓库名 标签名, 默认Git是不会将标签推送到远程仓库的</li>
</ul>


<h2>11. 比较差异</h2>

<p>在实际工作中，对比文件在不同版本中有何差异是经常发生的事情。</p>

<p>在git中，我们可以通过<code>git diff</code>来比较工作区和index、index和git仓库、工作区和git仓库、不同版本同一文件等之间的差异。</p>

<ul>
<li><code>git diff</code>  比较了工作区与index的差异</li>
<li><code>git diff HEAD</code>   比较了工作区与仓库中最近一次的提交间的差异</li>
<li><code>git diff --cached</code>   比较了index与仓库中最近一次的提交间的差异</li>
<li><code>git diff HEAD^ HEAD</code>   比较了当最近的这次提交与上一次提交之间的差异</li>
<li><code>git diff 指定的分支</code>  比较了当前分支的HEAD与指定分支的HEAD之间的差异</li>
<li><code>git diff 分支1..分支2</code>  比较了分支1到分支2之间的变动</li>
</ul>


<p>更复杂的比较可以使用<code>git difftool</code>打开配置的diff工具来进行对比，上述的选项或参数也同样适用于git difftool，如<code>git difftool HEAD^ HEAD</code>。</p>

<h2>12. 紧急任务支援时保存当前分支的工作状态</h2>

<p>如果正在一个develop分支上正在开发新功能，但这时master分支(稳定版本)突然发现了bug，并需要及时修复，而develop分支此时的工作还没有完成，且不希望将之前的工作就这样提交到仓库中时，这时就可以用git stash来暂时保存这些状态到Git内部栈中，并用当前分支上一次的提交内容来恢复工作目录，然后切换到master分支进行bug修复工作，等修复完毕并提交到仓库上后，再使用<code>git stash apply [stash@{0}]</code>或者<code>git stash pop</code>将工作目录恢复到之前的状态，继续之前的工作。</p>

<p>同时也可以多次使用<code>git stash</code>将未提交的代码压入到Git栈中，但当多次使用&#8217;git stash&#8217;命令后，Git栈里将充满了未提交的代码，这时候到底要用哪个版本来恢复工作目录呢？<code>git stash list</code>命令可以将当前的Git栈信息打印出来，我们只需要将找到对应的版本号，例如使用<code>git stash apply stash@{1}</code>就可以用版本号为stash@{1}的内容来恢复工作目录。</p>

<p>当Git栈中所有的内容都被恢复后，可以使用<code>git stash clear</code>来将栈清空。</p>

<h2>13. 不同分支都在提交时，开发分支合并主分支内容，且不影响主分支</h2>

<p>假设master和develop是一个项目的两个分支，其中master是主分支，develop是从master而来的开发分支，如果在develop分支上提交过2次，之后又切换到master分支，做了一些修改并提交2次，这时，如果想将master分支的最新修改内容合并到develop分支，但同时也不能影响master分支时，就需要使用git rebase了，这时的上游分支为master。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>执行git rebase master前：
</span><span class='line'>              develop: 1 --> develop: 2
</span><span class='line'>            /
</span><span class='line'>master: 0 --> master: 1 --> master: 2
</span><span class='line'>
</span><span class='line'>执行git rebase master后：
</span><span class='line'>                                    develop: 1 --> develop: 2
</span><span class='line'>                                   /
</span><span class='line'>master: 0 --> master: 1 --> master: 2</span></code></pre></td></tr></table></div></figure>


<h2>14. 查看文件是何时被何人修改的</h2>

<p>如果找到某个版本出现了问题，而之前的版本没问题，我们可以用git blame找出文件是何时被何人怎么修改的。
<code>git blame [-L 行号1， 行号2] file</code></p>

<h2>15. 备份工作区的所有文件</h2>

<p><code>git archive --format=zip -o arch.zip HEAD</code> 或 <code>git arch --format zip head&gt;arch.zip</code></p>

<p>只备份了当前工作区的所有文件，不包括.git目录，会在工作目录中生成一个arch.zip文件。</p>

<h2>16. 查找问题是在哪个版本被引入的</h2>

<p>如果我们发现有个问题在某些版本没问题，而在有些版本有问题时，我们可以借助git bisect来帮助我们定位问题。
<code>git bisect start</code>
<code>git bisect good commit-id1</code>
<code>git bisect bad commit-id2</code>
这时，git会按照二分法找出good版本和bad版本中间的那个提交版本，并自动将工作状态切换到那个版本，这时我们可以验证这个版本是不是有问题，如果有问题，通过<code>git bisect bad</code>告诉git，这时git会继续找出一个中间版本让我们来验证，直到我们找出，并通过<code>git bisect good</code>告诉git为止。</p>

<p>这样一步一步我们就可以找出引入问题的版本，最后，我们可以使用<code>git bisect reset</code>结束查找，git会删除查找过程中在仓库中生成的临时文件，并将状态恢复到。</p>

<h2>17. 养成定期清理垃圾的习惯</h2>

<p>执行<code>git gc</code>，git会帮助我们清除仓库中垃圾，释放一些空间，并以pack的压缩方式存储对象内容，其中，.git/refs目录中内容和.git/objects目录下的对象文件会被压缩存放到.git/objects/pack目录下，而在.git/objects/info目录下会有一个packs文件用于指向.git/objects/pack目录下的一个pack文件，而这个pack文件应该是存放压缩分支、tag等信息后的文件。</p>

<p>(全文完)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git学习笔记]]></title>
    <link href="http://shanewfx.github.com/blog/2012/04/21/learn-git-command/"/>
    <updated>2012-04-21T13:39:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/04/21/learn-git-command</id>
    <content type="html"><![CDATA[<p>前一段时间在<a href="https://github.com/">Github</a>上用<a href="https://github.com/imathis/octopress">Octopress</a>搭建了博客，从此，就需要和<strong>Git</strong>不断打交道，虽然用到的Git命令不是很多。</p>

<p>刚好，这几天x64移植项目告一段落，有了点空闲时间，想想还是系统地去学习一下Git吧。</p>

<p>当然，学习Git，我也希望在今后的开发中能够用Git来管理自己的Code，结束之前那种最原始的、靠每天备份的笨方法。</p>

<p>关于Git的教程，网上有不少，感觉用的人也挺多的，所以一般的资料和问题解决方法基本通过Google都能够获得。</p>

<p>这里，关于Git的历史、原理等不会涉及太多，主要是从自身日常管理Code这个角度去谈谈如何使用Git管理代码，让自己先达到能够熟练Git这个目标。</p>

<!--more-->


<h2>起点</h2>

<p>我学习Git的起点是从阅读<a href="http://progit.org/book/zh/">Pro Git</a>开始，感觉各种概念讲解的还是蛮清楚的，涉及Git的很多方面，是一份很不错的资料。</p>

<p>另外，<a href="http://gitbook.liuhui998.com/index.html">git community book</a>和<a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_tw/index.html">Git Magic</a>也值得参考一下。</p>

<p>还有一份<a href="http://files.cnblogs.com/phphuaibei/git%E6%90%AD%E5%BB%BA.pdf">Git使用指南</a> 作为使用Git管理Code的入门资料也是很不错的。</p>

<h2>工具</h2>

<p>我学习和使用Git的平台是<strong>Windows</strong>，所以安装一下<a href="http://code.google.com/p/msysgit/">msysGit</a>提供的安装文件即可，我安装的是<a href="http://code.google.com/p/msysgit/downloads/list">Git-1.7.7-preview20111014.exe</a>，不过目前已经更新到Git 1.7.10了。</p>

<p>安装完，就可以通过命令行工具<strong>Git Bash</strong>来使用Git了，我使用Git大多数时候是通过命令行的方式，当然在Windows下也支持图形界面的方式来使用Git，使用<strong>Git GUI</strong>就可以了。</p>

<p>不过，在Git GUI里有些特殊的功能可能没有支持，需要这些功能还是要切换到Git Bash中。</p>

<p>该工具还集成到了Windows的资源管理器中，在文件夹上右键，可以点击<strong>Git Bash Here</strong>和<strong>Git GUI Here</strong>快速启动Git并自动切换到指定的文件夹，方便了不少。</p>

<p>但有时，不知怎么突然无法通过该方法启动Git，上Google查了一下，发现是与Git相关的注册表项被修改了，可能是我使用了注册表清理工具造成的吧？</p>

<p>知道了原因，修复的方法也很简单，将下面的内容复制到一个文本文件中，保存后，将文件的扩展名修改为.reg，双击注册即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>REGEDIT4
</span><span class='line'>
</span><span class='line'>[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\git_shell]
</span><span class='line'>@="Git Ba&sh Here"
</span><span class='line'>
</span><span class='line'>[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\git_shell\command]
</span><span class='line'>@="wscript \"C:\\Program Files\\Git\\Git Bash.vbs\" %1"
</span><span class='line'>
</span><span class='line'>[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\git_gui]
</span><span class='line'>@="Git &GUI Here"
</span><span class='line'>
</span><span class='line'>[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\git_gui\command]
</span><span class='line'>@="\"C:\\Program Files\\Git\\bin\\wish.exe\" \"C:\\Program Files\\Git\\libexec\\git-core\\git-gui\" --working-dir %1"</span></code></pre></td></tr></table></div></figure>


<p>值得一提的是，如果开发工具是MS Virtual Studio的话，则有另外一个Git图形界面工具<a href="http://code.google.com/p/gitextensions/">Git Extension</a>可以使用，安装之后会集成到<strong>VS2005、VS2008、VS2010</strong>中，当然脱离MS Virtual Studio也可以单独使用，其图形界面的功能比上述的Git GUI要强大不少；同时，也集成到Windows资源管理器中，可以通过在文件夹上右键进入。</p>

<p>为了更深入地了解和掌握Git，下面基本是采用Git命令才演示各种操作。</p>

<h2>Git基本概念</h2>

<p>Git作为一个版本控制软件，相比其他版本控制软件有什么不同呢？</p>

<ul>
<li><p>Git是一个<strong>分布式</strong>的版本控制系统，一般来讲，各个Git仓库没有主次之分；</p></li>
<li><p>大多数的操作可以在本地完成，事后方便时，再推送到中心服务器的仓库中；</p></li>
<li><p>采用<strong>&#8220;直接记录快照，而非差异比较&#8221;</strong>的版本控制策略，内部只关心<strong>文件数据的整体是否发生改变，而不是文件内容的具体差异</strong>（Git内部被实现为一种微型的文件系统）；</p></li>
<li><p>Git工作时就是在<strong>工作目录（工作区、work tree）、暂存区（索引、index file）、本地仓库</strong>三者之间管理文件的变化情况，Git会监视工作目录中的文件变化(增加新文件，删除文件，修改文件等)，需要我们自己手动将变化的文件添加(git add)到暂存区中（这就是文件快照），然后再提交(git  commit)到本地仓库中；上述过程，涉及Git内部的三种对象：commit对象、tree对象和blob对象，blob对象会对应的文件快照中那些变化的文件内容，tree对象记录了文件快照中各个目录和文件的结构关系，从概念上讲，tree对象和blob对象组成了文件快照，commit对象则记录了这次要提交到本地仓库的文件快照，同时也会指向上次的commit对象，它也是Git内部进行版本控制的重点（Git内部会记录各个commit对象，并用HEAD来指示当前分支中最新的commit对象），很多重要的功能，如分支、版本回溯、Git仓库内部状态等都是在commit对象基础上实现的；上述的每一个对象都对应一个独一无二的ID，该ID是一个由40个字符组成的哈希码，由SHA-1算法计算而来；Git能够通过ID的前几个字符就识别出对应的对象；</p></li>
<li><p>Git的分支功能很强大，很灵活，切换速度非常快，并且实现成本很低，这也是Git比其他版本控制软件要受欢迎的原因之一；</p></li>
<li><p>Git拥有丰富的、功能强大的命令，一个命令通过配置不同的选项可以实现不同的功能；要学好Git，关键就是要掌握这些命令，并灵活使用它们；</p></li>
</ul>


<h2>Git常用命令解析</h2>

<p>Git中有许多命令，并且每种命令都有一些功能选项可被选择，因此，在不熟悉Git这些命令的时候，查阅这些命令的使用说明是不错的选择。</p>

<p>要查询Git命令，可以使用git help 命令或者git 命令 &#8211;help的方式，它会自动打开浏览器来查看。</p>

<h3>1. Git仓库创建</h3>

<p><code>git init</code></p>

<p>在项目的开始，必须使用该命令来创建和初始化Git仓库，它会在项目的文件夹下生成一个隐藏的<strong>.git文件夹</strong>，这就是这个项目的Git本地仓库，后面所有的Git命令操作都是针对该文件夹里的内容。执行过该命令后，原来的文件夹就成为了Git的工作目录。</p>

<p><em>Note：在一个已经初始化过的文件夹下再次执行<code>git init</code>，Git并不会将之前的.git文件夹的内容清除，这应该是Git的一种保护。</em></p>

<p>.git文件夹的初始组成如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.git
</span><span class='line'>   |
</span><span class='line'>   |--HEAD
</span><span class='line'>   |--description
</span><span class='line'>   |--config
</span><span class='line'>   |--[refs]
</span><span class='line'>   |----|
</span><span class='line'>   |----|--[heads]
</span><span class='line'>   |----|--[tags]
</span><span class='line'>   |--[objects]
</span><span class='line'>   |----|
</span><span class='line'>   |----|--[info]
</span><span class='line'>   |----|--[pack]
</span><span class='line'>   |--[info]
</span><span class='line'>   |----|
</span><span class='line'>   |----|--exclude
</span><span class='line'>   |--[hooks]
</span><span class='line'>   |----|
</span><span class='line'>   |----|--*.sample</span></code></pre></td></tr></table></div></figure>


<p>初始状态下，Git默认处于master分支，HEAD文件的内容为ref: refs/heads/master，但在refs/heads目录下却没有master文件；而objects文件夹下则没有文件。</p>

<p>在有过一次提交后，.git文件夹就会产生变化，如增加了logs文件夹，里面记录了git各种操作产生的log，我们通过git命令，如git log, git show, git reflog等可以查看这些log内容；
产生了一个index文件，这就是暂存区对应的文件; objects文件夹下新增了很多文件夹和文件，它们实际就是文件快照（tree对象和blob对象）存放的地方；
refs/heads文件夹下这时生成了master文件，其内容就是master分支最新commit对象对应的ID；如果有其他分支，则在refs/heads文件夹下也会生成以分支名命名的文件，里面存储着该分支最新commit对象的ID。</p>

<h3>2. 文件快照</h3>

<p><code>git add .</code></p>

<p>在Git中，工作目录下文件的状态可以分为已跟踪和未跟踪两大类状态，其中，已跟踪的文件是指已经被提交到git仓库的那些文件，而未跟踪的文件是指还没被提交到Git仓库中的那些非Git忽略的文件（Git可以通过在项目根目录下产生一个.gitignore文件，在里面指定要忽略的文件类型，这样Git就不会去监视这些文件的变化），如果工作目录中已跟踪的文件被修改或者删除，或者有新的文件（包括非空文件夹）加入，则通过<code>git status</code>可以查看到Git监视到文件变化情况，然后通过<code>git add .</code>做一次文件快照，并将其存储到暂存区（index文件）中，等待被提交到Git仓库中。</p>

<h3>3. 文件快照提交至仓库</h3>

<p><code>git commit -m '本次提交文件变化的描述信息'</code></p>

<p>如果工作目录中的文件变化已经被暂存（也可以同<code>git status</code>来查看），则说明这次的文件快照可以被提交到仓库中，并一直保存。</p>

<p>提交时，需要添加一些信息，这里最好要将这次的文件变化情况描述清楚，以便以后在版本回溯时能够了解到各版本之间的差别。</p>

<p>如果工作目录中仅是已跟踪的文件被修改或被删除，则可以不用先<code>git add .</code>，直接使用<code>git commit -am "描述信息"</code>即可。</p>

<h3>4. 查看工作目录文件状态</h3>

<p><code>git status</code></p>

<p>在git命令执行后，要养成通过<code>git status</code>查看git状态的习惯，以便及时了解文件变化的情况。通过<code>git status</code>可以知道文件的状态（已修改未暂存、已删除、已修改并已暂存等待提交、未跟踪）。</p>

<h3>5. 查看提交历史</h3>

<p><code>git log</code></p>

<p>通过<code>git log</code>可以查看当前分支的所有提交历史，知道每次提交的commit对象的ID以及提交时附加的描述信息等。要显示更多的信息，需要使用其支持的选项，如<code>git log -p</code>可以将每次提交的文件变化也显示出来。</p>

<p><em>Note ： <code>git log</code>显示的内容可能会比较多，但git bash上显示不下时，最下面会有一个冒号：，指示还有更多的内容，这是通过上下箭头就可以选择内容进行查看，要退出按q键即可，要查看其他命令，按h键。</em></p>

<h3>6. 查看指定的提交对象</h3>

<p><code>git show commit-id</code></p>

<p>通过<code>git log</code>可以显示整个提交历史，而通过<code>git show commit-id</code>则可以查看指定的某次提交内存，当然<code>git show -all</code>也可以显示出提交历史，另外还可以格式化显示内容。具体请查看其help。</p>

<p><em>Note : commit-id可以是commit对象对应的ID，也可以是HEAD，分支名，tag等。</em></p>

<h3>7. 查看工作目录/暂存区/仓库之间的差异</h3>

<ul>
<li><code>git diff</code>是比较工作目录与暂存区的差异</li>
<li><code>git diff HEAD</code>则是比较工作目录与仓库中最近一次的提交间的差异</li>
<li><code>git diff --cached</code>比较了暂存区与仓库中最近一次的提交间的差异。</li>
</ul>


<h3>8. 分支的创建、删除、切换、合并、查看</h3>

<p>Git一个比较吸引人的功能就是其强大的分支和合并功能。初始状态下，Git默认的分支为master。</p>

<ul>
<li>通过<code>git branch</code>可以查看目前Git仓库中已有的分支；</li>
<li>创建分支 ：<code>git branch 新分支名 [分支起点]</code>，没有分支起点的话，则默认在当前分支的最新的提交上创建分支</li>
<li>切换分支 ：<code>git checkout 分支名</code></li>
<li>创建同时切换到新分支 ：<code>git checkout -b 新分支名  [分支起点]</code></li>
<li>合并分支到master分支 ：<code>git checkout master</code>  <code>git merge 要被合并的分支名</code>，合并过程中如果发生冲突则需要自己手动解决冲突，然后再提交。有冲突时，Git会显示哪个文件有冲突，并在冲突的文件中加上特殊的标识符号，解决完冲突后，要手动去掉这些被添加的标识符号。如果冲突比较复杂的话，最好使用其他工具来协助，通过git mergetool来启动。冲突一般是在不同的分支上对同一文件的同一位置内容进行了改动，并已提交到仓库中，这样在合并的时候就会发生冲突。</li>
<li>删除已经被合并过的分支 ： <code>git branch -d 要删除的分支</code>名，如果分支没有被合并过，该命令会执行失败</li>
<li>删除分支，不管有没有被合并过 : <code>git branch -D 要删除的分支名</code></li>
<li>用图形界面查看分支提交历史 ： <code>gitk</code></li>
</ul>


<p><strong>充分利用好分支，可以帮助我们进行很好的版本控制与管理，如何用好分支其实是门艺术。</strong></p>

<p>基于分支的版本控制模型有一篇文章进行了很好的阐述。</p>

<p><a href="http://nvie.com/posts/a-successful-git-branching-model/">A succeddful Git branching model</a></p>

<p>中文翻译：<a href="http://roclinux.cn/?p=2129">Git分支管理是一门艺术</a></p>

<p><img src="http://shanewfx.github.com/images/blogImgs/201204/git-branch-all.png"></p>

<h3>9. 标签的添加、删除、查看</h3>

<p>标签可以在需要的地方，为某个提交对象创建别名，这样以后我们就可以通过标签来查看一些信息，创建分支等。</p>

<ul>
<li>查看标签 ：<code>git tag</code></li>
<li>创建简单的标签 ： <code>git tag 标签名</code></li>
<li>创建附加信息的标签 ： <code>git tag -a 标签名 -m '附加信息'</code></li>
<li>通过标签查看信息 ： <code>git show 标签名</code></li>
<li>删除标签 ： <code>git tag -d 标签名</code></li>
</ul>


<h3>10. 与远程仓库的交互</h3>

<p>Git相比其他版本控制软件的一个优点就是大多数的操作都可以在本地进行，而不用管远程的仓库，因为操作是在本地，且操作的数据也是在本地，所以执行的速度就会比较快。
在多人协作的项目中，就需要涉及与远程仓库交互的问题，主要是如何从远程仓库抓取最新数据合并到自己的本地分支上，将自己的最新成果分享给其他人或让别人审查等 。</p>

<ul>
<li>查看本地已经添加的远程仓库 ： <code>git remote</code>仅显示已添加的远程仓库名，<code>git remote -v</code>可以一并查看远程仓库的地址</li>
<li>在本添加远程仓库 ： <code>git remote add 远程仓库名 远程仓库地址</code></li>
<li>删除本地添加的远程仓库 ：<code>git remote rm 远程仓库名</code></li>
<li>重命名远程仓库名 ： <code>git remote rename 原名 新名</code></li>
<li>克隆远程仓库到本地 ： <code>git clone 远程仓库地址 [克隆到指定文件夹]</code></li>
<li>从远程仓库抓取最新数据到本地但不与本地分支进行合并 ： <code>git fetch 远程仓库名</code></li>
<li>从远程仓库抓取最新数据并自动与本地分支进行合并 ： <code>git pull 远程仓库名 本地要合并的分支名</code></li>
<li>将本地仓库推送到远程仓库中 ：<code>git push 远程仓库名 本地分支名</code></li>
<li>查看远程仓库信息 ： <code>git remote show 远程仓库名</code></li>
<li>将标签推送到远程仓库 ： <code>git push 远程仓库名 标签名</code>, 默认Git是不会将标签推送到远程仓库的</li>
</ul>


<h3>11. 查看所有分支的所有的commit和reset操作记录（包括已删除的commit记录）</h3>

<p>通过<code>git reflog</code>可以帮助我们获得将工作目录恢复到某个状态所需的ID(可以用HEAD@{数字}来表示对应的ID)。</p>

<h3>12. 撤销操作和版本回溯</h3>

<p>有时候，由于我们的误操作，产生了一些错误，我们发现后希望能够及时纠正这些因为误操作而产生的结果，将工作目录恢复到某个正常状态。</p>

<ul>
<li>撤销文件暂存，但还没有提交的文件： <code>git checkout -- filename</code> 或<code>git reset HEAD</code> ,修改的文件会被恢复到上次提交时的状态，修改的内容会丢失</li>
<li>版本回溯 ： [方法1] 根据分支或者标签将工作目录恢复到指定版本 : <code>git checkout 分支名或标签名</code>；
[方法2] 先通过<code>git reflog</code>找到某个版本的commit-ID，然后用<code>git reset --hard commit-ID</code>将工作目录的文件恢复到指定的版本</li>
<li>恢复工作目录中被删除的文件 (文件之前被提交到仓库中)：<code>git checkout -- filename</code> 或 <code>git checkout -f</code> 或 <code>git ls-files -d | xargs git checkout --</code></li>
</ul>


<h3>13. 备份工作目录</h3>

<p><code>git stash</code> <code>git stash list</code> <code>git stash apply</code> <code>git stash pop</code> <code>git stash clear</code></p>

<p>如果正在一个develop分支上正在开发新功能，但这时master分支(稳定版本)突然发现了bug，并需要及时修复，而develop分支此时的工作还没有完成，且不希望将之前的工作就这样提交到仓库中时，这时就可以用git stash来暂时保存这些状态到Git内部栈中，并用当前分支上一次的提交内容来恢复工作目录，然后切换到master分支进行bug修复工作，等修复完毕并提交到仓库上后，再使用<code>git stash apply [stash@{0}]</code>或者<code>git stash pop</code>将工作目录恢复到之前的状态，继续之前的工作。</p>

<p>同时也可以多次使用<code>git stash</code>将未提交的代码压入到Git栈中，但当多次使用&#8217;git stash&#8217;命令后，Git栈里将充满了未提交的代码，这时候到底要用哪个版本来恢复工作目录呢？<code>git stash list</code>命令可以将当前的Git栈信息打印出来，我们只需要将找到对应的版本号，例如使用<code>git stash apply stash@{1}</code>就可以用版本号为stash@{1}的内容来恢复工作目录。</p>

<p>当Git栈中所有的内容都被恢复后，可以使用<code>git stash clear</code>来将栈清空。</p>

<h3>14. 二分查找</h3>

<p><code>git bisect</code></p>

<h3>15. 垃圾回收</h3>

<p><code>git gc</code></p>

<h3>16. 将当前工作目录文件压缩归档（不包括.git目录）</h3>

<p><code>git archive --format=zip -o arch.zip HEAD</code> 或 <code>git arch --format zip head&gt;arch.zip</code></p>

<h3>17. 跟上游分支同步</h3>

<p><code>git rebase 上游分支名</code></p>

<p>假设master和develop是一个项目的两个分支，其中master是主分支，develop是从master而来的开发分支，如果在develop分支上提交过2次，之后又切换到master分支，做了一些修改并提交2次，这时，如果想将master分支的最新修改内容合并到develop分支，但同时也不能影响master分支时，就需要使用git rebase了，这时的上游分支为master。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>执行git rebase master前：
</span><span class='line'>              develop: 1 --> develop: 2
</span><span class='line'>            /
</span><span class='line'>master: 0 --> master: 1 --> master: 2
</span><span class='line'>
</span><span class='line'>执行git rebase master后：
</span><span class='line'>                                    develop: 1 --> develop: 2
</span><span class='line'>                                   /
</span><span class='line'>master: 0 --> master: 1 --> master: 2</span></code></pre></td></tr></table></div></figure>


<h3>18. 查看commit的次数</h3>

<p><code>git shortlog -s -n</code>会显示出总的提交次数。</p>

<h3>19. 查看仓库中commit对象、tree对象和blob对象</h3>

<p>在我们将文件提交到Git仓库后，我们可以通过每次的commit对象的ID来查看文件快照的内容。</p>

<p>具体的方法就是：</p>

<ul>
<li><p>先通过<code>git log</code>查看提交历史，选择需要查看的commit-id</p></li>
<li><p><code>git cat-file -t id</code>可以知道拥有该ID的对象是属于哪种类型：<strong>commit、tree、blob</strong></p></li>
<li><p><code>git cat-file commit id</code>可以查看到该commit对象指向的tree对象的ID</p></li>
<li><p><code>git ls-tree tree-id</code>可以查看该tree中的blob对象的ID和其他tree对象的ID（如果有）</p></li>
<li><p><code>git cat-file blob blob-id</code></p></li>
</ul>


<h3>20. 查看仓库中index文件</h3>

<p>通过<code>git ls-files --stage</code>可以查看当前分支的index文件中有哪些文件，它列出了文件名及对应的blob对象的ID。</p>

<h3>21. 查看仓库目录结构</h3>

<p><code>find</code>可以列出.git目录下所有目录和文件，这样就可以清楚地知道当前仓库的目录结构。</p>

<h3>22. 查看文件的修改历史</h3>

<p><code>git blame filename</code>可以列出该文件每次被修改的时间和内容。</p>

<h3>23. 常用的linux命令</h3>

<ul>
<li>创建文件夹 <code>mkdir</code></li>
<li>删除文件夹 <code>rmdir</code></li>
<li>查看文件列表 <code>ls</code></li>
<li>查看文件内容 <code>cat</code></li>
<li>回显 和 管道命令 <code>echo "hello" &gt;&gt; file.txt</code></li>
</ul>


<p>上述的这些命令应该能够帮助我们实现多数的版本控制需求，当然其中的每一个命令都会有一些其他的选项功能这里没有提到，希望在以后使用Git的过程中能够慢慢发掘，感受Git的强大！</p>

<p>很多内容是基于自己的理解，如有误请指正。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[x64 filter移植笔记]]></title>
    <link href="http://shanewfx.github.com/blog/2012/04/11/x64-filter-porting/"/>
    <updated>2012-04-11T17:53:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/04/11/x64-filter-porting</id>
    <content type="html"><![CDATA[<p>64位filter开发工具为VS2005，原来使用VC6开发的filter要转换到VS2005下。</p>

<p>32位的filter移植到x64平台上，对于没有汇编的filter，工作比较简单，主要就是编译选项的设置和修改指针与整形数相互强制转换的地方，以及部分数据类型不匹配等。</p>

<!--more-->


<h3>x64编译选项</h3>

<p>对于从VC6转换到VS2005的Project，其中x64编译选项主要注意以下几个地方：</p>

<ul>
<li><p>C/C++->Preprocessor->Preprocessor Definitions : 检查或移除、添加编译器预定义常量；对于Release版的filter，一般会包含WIN32;NDEBUG;<em>WINDOWS;</em>USRDLL;UNICODE版本要添加UNICODE;</p></li>
<li><p>C/C++->Code Generation->Runtime Library : 对于Release版本这里可能选择Multi-threaded(/MT)或者Multi-threaded DLL(/MD)，如果选择Multi-threaded(/MT)，如果编译报错则在Linker->Input->Addtional Dependencies中增加MSVCRT.LIB试试；</p></li>
<li><p>C/C++->Optimization->Whole Program Optimization : <strong>如果该选项为No，则用/MT编译出来的文件会比用/MD编译出来的文件大很多</strong>，因此，Release版本，该选项要设置为Enable link-time code generation(/GL)，不过对于Debug版本，该选择一般设为No，否则编译器有可能会报/GL与/ZI冲突；</p></li>
<li><p>Linker->Input->Addtional Dependencies : 至少包括 strmbase.lib strmiids.lib winmm.lib，其中 strmbase.lib根据编译环境（是不是预定义了UNICODE或Release版本/Debug版本）的不同可能为ustrmbase.lib,  strmbasd.lib或 ustrmbasd.lib；</p></li>
<li><p>Linker->Input->Ignore All Default Libraries : 要选择No，否则编译可能会报错；</p></li>
<li><p>Linker->Advanced->Entry Point : 如果填的是DllEntryPointer@12，则在x64下编译器会报错，win32下则不会报错（建议不要这样设定，而应该在代码中指定DLL入口为DllMain，并在DllMain中调用DllEntryPoint即可）；在x64下不要填；</p></li>
<li><p>Linker->Advanced->Base Address : 在x64下不要填，win32下如果Linker->Advanced->Entry Point填了DllEntryPointer@12，则这里通常设为0x1c400000；（建议不要这样设定）</p></li>
</ul>


<h3>指针与回调函数</h3>

<p>指针部分重点是要检查使用回调函数的地方，在Win32下，指针和int/long转换是可以的，因为都是32位长度，而在x64下，指针的长度为64位，而int/long仍是32位，这样原有的转换在x64下就会出现问题。在这些地方，要将int/long替换为ULONG_PTR，ULONG_PTR在Win32下为32位，而在x64下则为64位。</p>

<h3>数据类型warnings</h3>

<p>不对编译器报出的关于数据类型不匹配的Warnings，要检查并确认不会发生溢出或者截断，没有改变原有的值的情况下可以不用修改。当然，最好Coding的过程中就要避免数据类型可能存在的不匹配问题，否则出现问题时，查找原有就会麻烦了。</p>

<h3>汇编代码的修改</h3>

<p>对于有汇编的filter，移植64位版本，除了上述的问题，还涉及汇编代码的修改。</p>

<p>在VS2005 x64中不再支持内联汇编，编译器不再认识__asm关键字。</p>

<p>所以，对于内联汇编的代码，要将函数提取到单独的.asm文件中，并修改函数参数传递、局部变量的分配及堆栈、寄存器管理。这部分可参看<a href="http://shanewfx.github.com/blog/2012/03/26/vs2005-64bit-programming/">上篇</a>内容。</p>

<p>对于寄存器，在x64平台中，原来的32位寄存器被扩展到64位，并新增了8个64位的通用寄存器R8~R15，另外还增加了8个128位的XMM寄存器XMM8~XMM15。</p>

<p>同时，原来的32位通用寄存器仍然可以使用，但32位寄存器和新的64位寄存器混合使用时，要注意相互赋值的地方，应该要匹配。</p>

<p>另外，在内存访问的地方，x64中必须要通过PTR指明数据的类型，否则编译器会报错；而在Win32下则可以省略。</p>

<p>下面是ARGB转AYUV的一部分x64汇编代码示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>; extern "C" void ARGB2AYUV(BYTE* pDest, BYTE* pSrc, LONG lWidth, LONG lHeight, LONG lStride)
</span><span class='line'>; X64 assembly version
</span><span class='line'>
</span><span class='line'>.data
</span><span class='line'>ALIGN 16
</span><span class='line'>mask0000ffff   DQ    000000000ffffffffH, 000000000ffffffffH
</span><span class='line'>YbYgYrYa       DW    3736, 19235, 9798, 0, 3736, 19235, 9798, 0
</span><span class='line'>UbUgUrUa       DW    16384, -10879, -5505, 0, 16384, -10879, -5505, 0
</span><span class='line'>VbVgVrVa       DW    -2654, -13730, 16384, 0, -2654, -13730, 16384, 0
</span><span class='line'>const128       DW    128, 0, 128, 0, 128, 0, 128, 0
</span><span class='line'>F000           DW    0, 65280, 0, 65280, 0, 65280, 0, 65280
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>.code
</span><span class='line'>PUBLIC ARGB2AYUV
</span><span class='line'>ARGB2AYUV PROC
</span><span class='line'>    mov qword ptr [rsp+ 8], rcx ;pDest
</span><span class='line'>    mov qword ptr [rsp+16], rdx ;pSrc
</span><span class='line'>    mov dword ptr [rsp+24], r8d ;lWidth
</span><span class='line'>    mov dword ptr [rsp+32], r9d ;lHeight
</span><span class='line'>   
</span><span class='line'>    push rbp
</span><span class='line'>    push rdi
</span><span class='line'>    push rsi
</span><span class='line'>    mov rbp, rsp
</span><span class='line'>    sub rsp, 16
</span><span class='line'>   
</span><span class='line'>    ;int iCycle  = lWidth >> 2;
</span><span class='line'>    mov eax, dword ptr [rbp+48]  ;lWidth
</span><span class='line'>    sar eax, 2                   ;lWidth>>2
</span><span class='line'>    mov dword ptr [rbp-16], eax  ;iCycle
</span><span class='line'>   
</span><span class='line'>    ;int iRemain = lStride - (lWidth &lt;&lt; 2);
</span><span class='line'>    mov eax, dword ptr [rbp+48]  ;lWidth
</span><span class='line'>    shl eax, 2                   ;lWidth&lt;&lt;2
</span><span class='line'>    mov ecx, dword ptr [rbp+64]  ;lStride
</span><span class='line'>    sub     ecx, eax
</span><span class='line'>    mov     eax, ecx
</span><span class='line'>    mov qword ptr [rbp-8], 0     ;add for iRemain = 0
</span><span class='line'>    mov dword ptr [rbp-8], eax   ;iRemain
</span><span class='line'>
</span><span class='line'>    ;prepare 
</span><span class='line'>    mov rdx, qword ptr [rbp+32]  ;pDest
</span><span class='line'>    mov rcx, qword ptr [rbp+40]  ;pSrc
</span><span class='line'>    mov edi, dword ptr [rbp+56]  ;lHeight
</span><span class='line'>    mov rsi, qword ptr [rbp- 8]  ;iRemain
</span><span class='line'>    
</span><span class='line'>    pxor xmm0, xmm0
</span><span class='line'>    
</span><span class='line'>NextLine:
</span><span class='line'>    mov     eax, dword ptr [rbp-16]  ;iCycle
</span><span class='line'>NextCycle:
</span><span class='line'>    movdqa xmm1, [rcx]       ;A3 R3 G3 B3 A2 R2 G2 B2 A1 R1 G1 B1 A0 R0 G0 B0
</span><span class='line'>    movdqa xmm2, xmm1        ;A3 R3 G3 B3 A2 R2 G2 B2 A1 R1 G1 B1 A0 R0 G0 B0
</span><span class='line'>
</span><span class='line'>    punpcklbw xmm1, xmm0     ;00 A1 00 R1 00 G1 00 B1 00 A0 00 R0 00 G0 00 B0
</span><span class='line'>    punpckhbw xmm2, xmm0     ;00 A3 00 R3 00 G3 00 B3 00 A2 00 R2 00 G2 00 B2
</span><span class='line'>
</span><span class='line'>    ;y = (9798*r + 19235*g + 3736*b) / 32768
</span><span class='line'>    movdqa     xmm3, xmm1    ;00 A1 00 R1 00 G1 00 B1 00 A0 00 R0 00 G0 00 B0
</span><span class='line'>    movdqa     xmm4, xmm2    ;00 A3 00 R3 00 G3 00 B3 00 A2 00 R2 00 G2 00 B2
</span><span class='line'>
</span><span class='line'>    pmaddwd     xmm3, xmmword ptr YbYgYrYa    
</span><span class='line'>    pmaddwd xmm4, xmmword ptr YbYgYrYa    
</span><span class='line'>
</span><span class='line'>    pshufd     xmm5, xmm3, 0b1h
</span><span class='line'>    pshufd     xmm6, xmm4, 0b1h
</span><span class='line'>
</span><span class='line'>    paddd     xmm3, xmm5      ;Y1 Y1 Y0 Y0
</span><span class='line'>    paddd     xmm4, xmm6      ;Y3 Y3 Y2 Y2
</span><span class='line'>
</span><span class='line'>    psrad xmm3, 15
</span><span class='line'>    psrad xmm4, 15
</span><span class='line'>    pand  xmm3, xmmword ptr mask0000ffff ;0 Y1 0 Y0
</span><span class='line'>    pand  xmm4, xmmword ptr mask0000ffff ;0 Y3 0 Y2
</span><span class='line'>
</span><span class='line'>    packssdw xmm3, xmm4        ;0 Y3 0 Y2 0 Y1 0 Y0........
</span><span class='line'>
</span><span class='line'>    ;u = (-5505*r - 10879*g + 16384*b) / 32768
</span><span class='line'>    ;此处省略
</span><span class='line'>    ;v = (16384*r - 13730*g - 2654*b) / 32768
</span><span class='line'>    ;此处省略
</span><span class='line'>
</span><span class='line'>    ;begin to next
</span><span class='line'>    add rdx, 16
</span><span class='line'>    add rcx, 16
</span><span class='line'>    dec eax
</span><span class='line'>    jnz NextCycle
</span><span class='line'>    add rdx, rsi
</span><span class='line'>
</span><span class='line'>    dec edi
</span><span class='line'>    jnz NextLine
</span><span class='line'>    
</span><span class='line'>    ;exit
</span><span class='line'>    add rsp, 16
</span><span class='line'>    pop rsi
</span><span class='line'>    pop rdi
</span><span class='line'>    pop rbp    
</span><span class='line'>    emms
</span><span class='line'>    ret
</span><span class='line'>      
</span><span class='line'>ARGB2AYUV ENDP
</span><span class='line'>End</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VS2005 64-bit Programming Note]]></title>
    <link href="http://shanewfx.github.com/blog/2012/03/26/vs2005-64bit-programming/"/>
    <updated>2012-03-26T17:47:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/03/26/vs2005-64bit-programming</id>
    <content type="html"><![CDATA[<p>最近接到的任务是将32位的directshow filter移植到64位平台下，因此，借此机会学习了一点关于64位编程方面的内容。</p>

<p>由于平时的开发环境是Windows + VS2005，所以，下面的内容也主要是讨论VS2005下64位编程的一些主要事项。不过，对于其他平台下的64位编程也有参考价值。</p>

<p>之前已经讲过如何搭建VS2005下64位编程环境，看<a href="http://shanewfx.github.com/blog/2012/03/18/64bit-programming/">这里</a>。</p>

<!--more-->


<h2>关于Windows下64位编程，有如下几篇文章可做参考：</h2>

<ul>
<li><p><a href="http://www.microsoft.com/china/MSDN/library/Windev/64bit/issuesx64.mspx?mfr=true">开始进行64位Windows系统编程之前需要了解的所有信息</a></p></li>
<li><p><a href="http://www.viva64.com/en/l/full/">Lessons on development of 64-bit C/C++ applications</a>, <a href="http://www.cnblogs.com/walfud/articles/2291839.html">中文学习笔记</a></p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/bb427430.aspx">Programming Guide for 64-bit Windows</a></p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/aa384198.aspx">Getting Ready for 64-bit Windows</a></p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/aa384214.aspx">Migration Tips</a></p></li>
<li><p><a href="http://www.usidcbbs.com/read.php?tid=5247">用VC进行64位编程</a></p></li>
<li><p><a href="http://wenku.baidu.com/view/61804438376baf1ffc4fad48.html">Introduction_to_x64_Assembly</a></p></li>
</ul>


<h2>VS2005下64位编程注意事项</h2>

<h3>1. 数据类型模型改变</h3>

<p>Windows 32位平台下使用的是ILP32模型，而Windows 64位平台下使用LLP64模型。</p>

<p>在LLP64模型中，只有指针为64位，其余的类型则保证和32位平台一致:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char   -> 1byte
</span><span class='line'>short  -> 2bytes
</span><span class='line'>int    -> 4bytes
</span><span class='line'>long   -> 4bytes</span></code></pre></td></tr></table></div></figure>


<p>Windows平台为开发者提供了很多的数据类型别名，合理使用这些数据类型为我们编写32位和64位共用代码是有帮助的。</p>

<p>长度固定的类型：
INT32、UINT32、LONG32、ULONG32、DWORD32、INT64、UINT64、LONG64、ULONG64、DWORD64</p>

<p>随平台长度变化的类型（32位平台->32位，64位平台->64位）：
INT_PTR、UINT_PTR、LONG_PTR、ULONG_PTR、DWORD_PTR、SIZE_T、SSIZE_T、HALF_PTR、UHALF_PTR</p>

<p>指针：
POINTER_32、POINTER_64</p>

<p>由于数据类型模型的改变，因此，如果原代码中有涉及指针与整数类型之间相互转换（如在设置回调函数指针时，通常会将原模块的this指针作为long型保存起来），则这部分代码必须要改变（将long改为ULONG_PTR），即任何在代码中有假设指针与整数类型位数相同的代码在64位下都会有问题。</p>

<p>涉及指针运算的地方，要检测偏移量是否可能会溢出的问题。（偏移量是通过无符号数和有符号数运算得来的，特别容易出现问题）</p>

<p>另外，64位系统的API函数参数的数据类型可能发生了改变，如LPARAM，WPARAM，LRESULT在32位平台下是32位整型，而在64位平台下则为64位整型，这也是在移植过程中需要注意的地方，防止出现数据截断。</p>

<p>如果API或者自己代码中使用了size_t和ptrdiff_t，要注意它们的长度在32位平台为32位，在64位平台则是64位，这是特别容易出现数据截断的地方。</p>

<p>函数重载（多态）也要留意是否是仅依靠参数的数据类型来区分的。</p>

<p>代码中魔术数也是要check的地方，如果是魔术数是用来假设数据类型的size时，最好要使用sizeof来确定数据类型的size; 另外，魔术数不管是在32位平台还是在64位平台都是被当作一个32位的整型数来处理，特别要留意将-1作为错误码的地方，在32位平台下为0xFFFFFFFF, 而在64为平台下则应该为0xFFFFFFFFFFFFFFFF。如果代码中使用了0xFFFFFFFF这个整型数，那么在32位平台下为-1, 但在64位下却是一个很大的值(0x00000000FFFFFFFF)。因此，代码中有移位操作和使用MASK的地方，也是容易出现数据溢出的地方。</p>

<p>在代码中，打印整型数和指针的地方也需要注意，打印UINT_PTR整数将%u改为%Iu, 对于指针使用%p。</p>

<h3>2. 汇编代码</h3>

<p>在VS2005下64位编程不再支持内联汇编，汇编代码需要提取到一个单独的.ASM文件中。</p>

<p>编写64位平台汇编代码需要注意以下几个与32位平台汇编的不同的地方：</p>

<ul>
<li>扩展并增加了寄存器</li>
</ul>


<p>[32位] EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP -> [64位] RAX、RBX、RCX、RDX、RSI、RDI、RBP、RSP</p>

<p>可以在64位程序中调用32位的寄存器，如RAX（64位）、EAX（低32）、AX（低16位）、AL（低8位）、AH（8到15位），
相应的有R8、R8D、R8W和R8B，不过不要在程序中使用如AH之类的寄存器</p>

<p>增加了以下寄存器：R8 ~ R15  XMM8 ~ XMM15</p>

<ul>
<li>函数调用约定和参数传递方式</li>
</ul>


<p>x64平台函数calling convention与x86平台函数calling convention是不同的。</p>

<p>在x86平台下，函数调用约定有：<code>__cdecl、__stdcall、__fastcall、__thiscall</code>等，而x64下的调用约定只作如下限制：</p>

<ul>
<li>前4个整数参数（从左至右）通过4个寄存器传递：RCX、RDX、R8、R9，前4个以外的整数参数将传递到堆栈, 指针被视为整数参数;</li>
</ul>


<p>对于浮点参数，前4个参数将传入XMM0到XMM3的寄存器，后续的浮点参数也是通过堆栈传递。</p>

<p>即使参数可以是通过寄存器传递，但在堆栈上仍需为其预留空间，每个函数至少要在堆栈上预留32个字节（为前4个参数预留空间）, 该空间允许将传递函数函数的寄存器轻松地复制到堆栈中。</p>

<p>当然，如果要传递4个以上的参数，则必须为其预额外的堆栈空间。</p>

<ul>
<li>调用者负责椎栈空间的分配与回收，被调用函数不需要自己负责平衡堆栈（仅用于传递参数的这部分堆栈空间）</li>
</ul>


<p>注意，被调用函数中有局部变量和保存其他寄存器时，其空间是由被调用函数来分配，并在结束时由自己去回收这部分堆栈空间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>|参数6| &lt;-------------------- rsp + 48  &lt;------------ 栈底 
</span><span class='line'>|参数5| &lt;-------------------- rsp + 40
</span><span class='line'>|参数4| &lt;-------------------- rsp + 32 (R9)
</span><span class='line'>|参数3| &lt;-------------------- rsp + 24 (R8)
</span><span class='line'>|参数2| &lt;-------------------- rsp + 16 (RDX)
</span><span class='line'>|参数1| &lt;-------------------- rsp + 8  (RCX)
</span><span class='line'>|函数返回地址| &lt;------------- rsp
</span><span class='line'>|局部变量...|  &lt;------------- rsp会向低地址移动，上述的取参数的偏移地址也需要改动</span></code></pre></td></tr></table></div></figure>


<p>如int foo(int a, int b, int c, int d, int e, int f) { int i, j; return 0; }</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>|参数f| &lt;-------------------- rbp + 80  &lt;------------ 栈底 
</span><span class='line'>|参数e| &lt;-------------------- rbp + 72
</span><span class='line'>|参数d| &lt;-------------------- rbp + 64 (R9)
</span><span class='line'>|参数c| &lt;-------------------- rbp + 56 (R8)
</span><span class='line'>|参数b| &lt;-------------------- rbp + 48 (RDX)
</span><span class='line'>|参数a| &lt;-------------------- rbp + 40 (RCX)
</span><span class='line'>|函数返回地址| &lt;------------- rbp + 32 ==> 没有分配局部变量空间和保存寄存器前的rsp
</span><span class='line'>|保存RBP|      &lt;------------- rbp + 24
</span><span class='line'>|保存RBX|      &lt;------------- rbp + 16
</span><span class='line'>|保存RSI|      &lt;------------- rbp + 8
</span><span class='line'>|保存RDI|      &lt;------------- rbp - 0  ==> 分配局部变量空前的rsp，并将rsp保存到rbp中         
</span><span class='line'>|局部变量j|    &lt;------------- rbp - 8   &lt;------------ rsp' + 8
</span><span class='line'>|局部变量i|    &lt;------------- rbp - 24  &lt;------------ rsp'     (局部变量先定义的在低地址)</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MOV [RSP+ 8], RCX
</span><span class='line'>MOV [RSP+16], RDX
</span><span class='line'>MOV [RSP+24], R8
</span><span class='line'>MOV [RSP+32], R9
</span><span class='line'>PUSH RBP
</span><span class='line'>PUSH RBX
</span><span class='line'>PUSH RSI
</span><span class='line'>PUSH RDI
</span><span class='line'>MOV RBP, RSP
</span><span class='line'>SUB RSP, 16
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>ADD RSP, 16
</span><span class='line'>POP RDI
</span><span class='line'>POP RSI
</span><span class='line'>POP RBX
</span><span class='line'>POP RBP
</span><span class='line'>RET</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Simple Log Tool]]></title>
    <link href="http://shanewfx.github.com/blog/2012/03/18/a-simple-log-tool/"/>
    <updated>2012-03-18T20:10:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/03/18/a-simple-log-tool</id>
    <content type="html"><![CDATA[<p>对于程序员来说，debug是再正常不过的事。</p>

<p>在遇到问题时，通过分析程序的产生的Log文件来查找和验证问题发生的原因。</p>

<p>下面是一个简单的log tool，可以满足一般的log需求。</p>

<p>代码已经放到Github上了，需要的可到<a href="https://github.com/shanewfx/Log">这里</a>下载。</p>

<!--more-->


<p>该log tool实现了log分级，也支持自己指定log file的存放位置，缺省情况下，log文件为<code>C:\DebugInfo.log</code>。</p>

<p>因为log没有加锁，所以在多线程下产生的log会有错乱的现象，因此，在多线程中，可以在Log()函数的开始处加锁来解决。</p>

<hr />

<h3>log.h</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifndef _LOG_H
</span><span class='line'>#define _LOG_H
</span><span class='line'>
</span><span class='line'>#include &lt;string>
</span><span class='line'>
</span><span class='line'>#define TEST
</span><span class='line'>#define LOG_FILE_PATH "C:\\DebugInfo.log"
</span><span class='line'>
</span><span class='line'>#ifdef TEST
</span><span class='line'>  #define LogData Logger::Instance().Log
</span><span class='line'>  #define SetLogFile Logger::SetLogFilePath
</span><span class='line'>#else
</span><span class='line'>  #define LogData
</span><span class='line'>  #define SetLogFile
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>typedef enum tagLogLevel
</span><span class='line'>{
</span><span class='line'>  LOG_TRACE,
</span><span class='line'>  LOG_INFO,
</span><span class='line'>  LOG_WARNING,
</span><span class='line'>  LOG_ERROR,
</span><span class='line'>  LOG_FATAL,
</span><span class='line'>  LOG_NONE = 10,
</span><span class='line'>}LogLevel;
</span><span class='line'>
</span><span class='line'>class Logger
</span><span class='line'>{
</span><span class='line'>public:
</span><span class='line'>  static Logger& Instance();
</span><span class='line'>
</span><span class='line'>  static void SetLogFilePath(const std::string& strFilePath, bool bAppend = false);
</span><span class='line'>  static void SetLogLevel(const LogLevel Level);
</span><span class='line'>  static void Initialise(bool bAppend = false);
</span><span class='line'>  static void Dispose();
</span><span class='line'>
</span><span class='line'>  void Log(const LogLevel Level, const char *Format, ...);
</span><span class='line'>
</span><span class='line'>private:
</span><span class='line'>  Logger();
</span><span class='line'>  Logger(Logger const&);
</span><span class='line'>  Logger& operator=(Logger const&);
</span><span class='line'>  ~Logger();
</span><span class='line'>
</span><span class='line'>  static FILE*        m_hLogFile;
</span><span class='line'>  static std::string  m_strFilePath;
</span><span class='line'>  static LogLevel     m_LogLevel;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>#endif//_LOG_H</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>log.cpp</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "log.h"
</span><span class='line'>#include &lt;stdarg.h>
</span><span class='line'>#include &lt;windows.h>
</span><span class='line'>
</span><span class='line'>FILE* Logger::m_hLogFile = NULL;
</span><span class='line'>LogLevel Logger::m_LogLevel = LOG_TRACE;
</span><span class='line'>std::string Logger::m_strFilePath = LOG_FILE_PATH;
</span><span class='line'>
</span><span class='line'>const char* LogLevelStr[] = {
</span><span class='line'>    "TRACE",
</span><span class='line'>    "INFO",
</span><span class='line'>    "WARNING",
</span><span class='line'>    "ERROR",
</span><span class='line'>    "CRITICAL",
</span><span class='line'>    "FATAL",
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>Logger& Logger::Instance() 
</span><span class='line'>{
</span><span class='line'>  static Logger LoggerInstance;
</span><span class='line'>  return LoggerInstance;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void Logger::SetLogFilePath(const std::string& strFilePath, bool bAppend)
</span><span class='line'>{
</span><span class='line'>  m_strFilePath = strFilePath;
</span><span class='line'>  Dispose();
</span><span class='line'>  Initialise(bAppend);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void Logger::SetLogLevel(const LogLevel Level)
</span><span class='line'>{
</span><span class='line'>  m_LogLevel = Level;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Logger::Logger()
</span><span class='line'>{
</span><span class='line'>  Initialise(false);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>Logger::~Logger()
</span><span class='line'>{
</span><span class='line'>  Dispose();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void Logger::Initialise(bool bAppend)
</span><span class='line'>{
</span><span class='line'>  if (m_strFilePath.length() > 0) {
</span><span class='line'>      m_hLogFile = bAppend ? fopen(m_strFilePath.c_str(), "a+") 
</span><span class='line'>                       : fopen(m_strFilePath.c_str(), "w+");  
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void Logger::Dispose()
</span><span class='line'>{
</span><span class='line'>  if (NULL != m_hLogFile) {
</span><span class='line'>      fflush(m_hLogFile);
</span><span class='line'>      fclose(m_hLogFile);
</span><span class='line'>      m_hLogFile = NULL;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void Logger::Log(const LogLevel Level, const char *Format, ...)
</span><span class='line'>{
</span><span class='line'>  if (m_LogLevel > Level) return;
</span><span class='line'>
</span><span class='line'>  if (NULL == m_hLogFile) return; 
</span><span class='line'>
</span><span class='line'>  char szBuffer[1024];
</span><span class='line'>
</span><span class='line'>  va_list args;
</span><span class='line'>  va_start(args, Format);
</span><span class='line'>  vsprintf(szBuffer, Format, args);
</span><span class='line'>  va_end(args);
</span><span class='line'>
</span><span class='line'>  SYSTEMTIME st;      
</span><span class='line'>  GetLocalTime(&st);
</span><span class='line'>  if (0 > fprintf(m_hLogFile, "[%02u:%02u:%02u:%03u]\t[%s]\t%s\n", 
</span><span class='line'>      st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, 
</span><span class='line'>      LogLevelStr[Level], szBuffer)) {
</span><span class='line'>      Dispose();
</span><span class='line'>  }
</span><span class='line'>  else {
</span><span class='line'>      fflush(m_hLogFile);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>log的使用示例</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "Log.h"
</span><span class='line'>
</span><span class='line'>LogData(LOG_TRACE, "log information\n");
</span><span class='line'>
</span><span class='line'>int i = 100;
</span><span class='line'>LogData(LOG_TRACE, "i = %d\n", i);
</span><span class='line'>
</span><span class='line'>int j = 10;
</span><span class='line'>LogData(LOG_TRACE, "i = %d, j = %d\n", i, j);
</span><span class='line'>
</span><span class='line'>SetLogFile("c:\\log.txt"); //set log file path</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
</feed>
